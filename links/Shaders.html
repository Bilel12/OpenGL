<!DOCTYPE html>
<!-- saved from url=(0048)http://learnopengl.com/#!Getting-started/Shaders -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
	<title>Shaders</title>
    <link rel="shortcut icon" type="image/ico" href="http://learnopengl.com/favicon.ico">
    <meta name="description" content="Learn OpenGL . com provides good and clear modern 3.3+ OpenGL tutorials with clear examples. A great resource to learn modern OpenGL aimed at beginners.">
	<meta name="fragment" content="!">
    <script async="" src="./Shaders_files/analytics.js.download"></script><script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-51879160-1', 'learnopengl.com');
      ga('send', 'pageview');

    </script>
	<script src="./Shaders_files/jquery-1.11.0.min.js.download"></script>
	<script src="./Shaders_files/hoverintent.js.download"></script>
	<link rel="stylesheet" type="text/css" href="./Shaders_files/layout.css">
    <link rel="stylesheet" type="text/css" href="./Shaders_files/obsidian.css">
    <script src="./Shaders_files/highlight.pack.js.download"></script>    
    <script src="./Shaders_files/functions.js.download"></script>
    <script type="text/javascript" src="./Shaders_files/MathJax.js.download"></script>
    <script>
    // Has to be loaded last due to content bug 
    MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
    </script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>  
        // OnPopState only works in Chrome when loading the page, so this has to be done manually the first time.        
        // $(document).ready(function() {
            // LoadPage();
        // });
		// var initialized = false;
        // window.onpopstate = function(event) {
            // if(initialized)            
                // LoadPage();
			// else
				// initialized = true;
        // };
        
         // Set up DISQUS
        var disqus_shortname = 'learnopengl';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();           
        
        $(document).ready(function() {            
            // load page initially 
            LoadPage();            
            window.onpopstate = function(event) {
                LoadPage();
            };
        });
       
    </script><script type="text/javascript" async="" src="./Shaders_files/embed.js.download"></script>
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div id="MathJax_Message" style="display: none;"></div>
<div id="header" onclick="LoadContent(&#39;Index&#39;, true, true)">
</div>
<div id="container">
<div id="loading" style="display: none"><img src="./Shaders_files/ajax-loader.gif" class="clean" style="margin-left: auto; margin-right: auto; margin-top: 150px;"></div>
<script> 
$(document).ready(function() {
$('#menu-item1').click(function(){ LoadContent('Introduction', true, true) });
$('#menu-item4').click(function() { MenuClick(4, true) });
$('#menu-item49').click(function(){ LoadContent('Getting-started/OpenGL', true, true) });
$('#menu-item5').click(function(){ LoadContent('Getting-started/Creating-a-window', true, true) });
$('#menu-item6').click(function(){ LoadContent('Getting-started/Hello-Window', true, true) });
$('#menu-item38').click(function(){ LoadContent('Getting-started/Hello-Triangle', true, true) });
$('#menu-item39').click(function(){ LoadContent('Getting-started/Shaders', true, true) });
$('#menu-item40').click(function(){ LoadContent('Getting-started/Textures', true, true) });
$('#menu-item43').click(function(){ LoadContent('Getting-started/Transformations', true, true) });
$('#menu-item44').click(function(){ LoadContent('Getting-started/Coordinate-Systems', true, true) });
$('#menu-item47').click(function(){ LoadContent('Getting-started/Camera', true, true) });
$('#menu-item50').click(function(){ LoadContent('Getting-started/Review', true, true) });
$('#menu-item48').click(function() { MenuClick(48, true) });
$('#menu-item51').click(function(){ LoadContent('Lighting/Colors', true, true) });
$('#menu-item52').click(function(){ LoadContent('Lighting/Basic-Lighting', true, true) });
$('#menu-item53').click(function(){ LoadContent('Lighting/Materials', true, true) });
$('#menu-item54').click(function(){ LoadContent('Lighting/Lighting-maps', true, true) });
$('#menu-item55').click(function(){ LoadContent('Lighting/Light-casters', true, true) });
$('#menu-item58').click(function(){ LoadContent('Lighting/Multiple-lights', true, true) });
$('#menu-item57').click(function(){ LoadContent('Lighting/Review', true, true) });
$('#menu-item56').click(function() { MenuClick(56, true) });
$('#menu-item59').click(function(){ LoadContent('Model-Loading/Assimp', true, true) });
$('#menu-item60').click(function(){ LoadContent('Model-Loading/Mesh', true, true) });
$('#menu-item61').click(function(){ LoadContent('Model-Loading/Model', true, true) });
$('#menu-item63').click(function() { MenuClick(63, true) });
$('#menu-item72').click(function(){ LoadContent('Advanced-OpenGL/Depth-testing', true, true) });
$('#menu-item73').click(function(){ LoadContent('Advanced-OpenGL/Stencil-testing', true, true) });
$('#menu-item74').click(function(){ LoadContent('Advanced-OpenGL/Blending', true, true) });
$('#menu-item77').click(function(){ LoadContent('Advanced-OpenGL/Face-culling', true, true) });
$('#menu-item65').click(function(){ LoadContent('Advanced-OpenGL/Framebuffers', true, true) });
$('#menu-item66').click(function(){ LoadContent('Advanced-OpenGL/Cubemaps', true, true) });
$('#menu-item69').click(function(){ LoadContent('Advanced-OpenGL/Advanced-Data', true, true) });
$('#menu-item67').click(function(){ LoadContent('Advanced-OpenGL/Advanced-GLSL', true, true) });
$('#menu-item68').click(function(){ LoadContent('Advanced-OpenGL/Geometry-Shader', true, true) });
$('#menu-item70').click(function(){ LoadContent('Advanced-OpenGL/Instancing', true, true) });
$('#menu-item75').click(function(){ LoadContent('Advanced-OpenGL/Anti-Aliasing', true, true) });
$('#menu-item100').click(function() { MenuClick(100, true) });
$('#menu-item101').click(function(){ LoadContent('Advanced-Lighting/Advanced-Lighting', true, true) });
$('#menu-item110').click(function(){ LoadContent('Advanced-Lighting/Gamma-Correction', true, true) });
$('#menu-item102').click(function() { MenuClick(102, true) });
$('#menu-item103').click(function(){ LoadContent('Advanced-Lighting/Shadows/Shadow-Mapping', true, true) });
$('#menu-item104').click(function(){ LoadContent('Advanced-Lighting/Shadows/Point-Shadows', true, true) });
$('#menu-item105').click(function(){ LoadContent('Advanced-Lighting/Shadows/CSM', true, true) });
$('#menu-item106').click(function(){ LoadContent('Advanced-Lighting/Normal-Mapping', true, true) });
$('#menu-item107').click(function(){ LoadContent('Advanced-Lighting/Parallax-Mapping', true, true) });
$('#menu-item111').click(function(){ LoadContent('Advanced-Lighting/HDR', true, true) });
$('#menu-item112').click(function(){ LoadContent('Advanced-Lighting/Bloom', true, true) });
$('#menu-item108').click(function(){ LoadContent('Advanced-Lighting/Deferred-Shading', true, true) });
$('#menu-item109').click(function(){ LoadContent('Advanced-Lighting/SSAO', true, true) });
$('#menu-item113').click(function() { MenuClick(113, true) });
$('#menu-item114').click(function(){ LoadContent('PBR/Theory', true, true) });
$('#menu-item115').click(function(){ LoadContent('PBR/Lighting', true, true) });
$('#menu-item116').click(function(){ LoadContent('PBR/IBL', true, true) });
$('#menu-item78').click(function() { MenuClick(78, true) });
$('#menu-item79').click(function(){ LoadContent('In-Practice/Debugging', true, true) });
$('#menu-item80').click(function(){ LoadContent('In-Practice/Text-Rendering', true, true) });
$('#menu-item81').click(function() { MenuClick(81, true) });
$('#menu-item82').click(function(){ LoadContent('In-Practice/2D-Game/Breakout', true, true) });
$('#menu-item88').click(function(){ LoadContent('In-Practice/2D-Game/Setting-up', true, true) });
$('#menu-item83').click(function(){ LoadContent('In-Practice/2D-Game/Rendering-Sprites', true, true) });
$('#menu-item84').click(function(){ LoadContent('In-Practice/2D-Game/Levels', true, true) });
$('#menu-item85').click(function() { MenuClick(85, true) });
$('#menu-item95').click(function(){ LoadContent('In-Practice/2D-Game/Collisions/Ball', true, true) });
$('#menu-item96').click(function(){ LoadContent('In-Practice/2D-Game/Collisions/Collision-detection', true, true) });
$('#menu-item97').click(function(){ LoadContent('In-Practice/2D-Game/Collisions/Collision-resolution', true, true) });
$('#menu-item89').click(function(){ LoadContent('In-Practice/2D-Game/Particles', true, true) });
$('#menu-item90').click(function(){ LoadContent('In-Practice/2D-Game/Postprocessing', true, true) });
$('#menu-item91').click(function(){ LoadContent('In-Practice/2D-Game/Powerups', true, true) });
$('#menu-item94').click(function(){ LoadContent('In-Practice/2D-Game/Audio', true, true) });
$('#menu-item92').click(function(){ LoadContent('In-Practice/2D-Game/Render-text', true, true) });
$('#menu-item93').click(function(){ LoadContent('In-Practice/2D-Game/Final-thoughts', true, true) });
$('#menu-item99').click(function(){ LoadContent('Code-repository', true, true) });
$('#menu-item98').click(function(){ LoadContent('Offline-book', true, true) });
$('#menu-item2').click(function(){ LoadContent('About', true, true) });
}); 
</script>        <div id="nav">
        <ol><li id="Introduction"><span id="menu-item1">Introduction </span></li><li id="Getting-started"><span id="menu-item4" class="open">Getting started </span><ol id="menu-items-of4" style=""><li id="Getting-started/OpenGL"><span id="menu-item49">OpenGL </span></li><li id="Getting-started/Creating-a-window"><span id="menu-item5">Creating a window </span></li><li id="Getting-started/Hello-Window"><span id="menu-item6">Hello Window </span></li><li id="Getting-started/Hello-Triangle"><span id="menu-item38">Hello Triangle </span></li><li id="Getting-started/Shaders"><span id="menu-item39" class="selected">Shaders </span></li><li id="Getting-started/Textures"><span id="menu-item40">Textures </span></li><li id="Getting-started/Transformations"><span id="menu-item43">Transformations </span></li><li id="Getting-started/Coordinate-Systems"><span id="menu-item44">Coordinate Systems </span></li><li id="Getting-started/Camera"><span id="menu-item47">Camera </span></li><li id="Getting-started/Review"><span id="menu-item50">Review </span></li></ol></li><li id="Lighting"><span id="menu-item48" class="open">Lighting </span><ol id="menu-items-of48" style=""><li id="Lighting/Colors"><span id="menu-item51">Colors </span></li><li id="Lighting/Basic-Lighting"><span id="menu-item52">Basic Lighting </span></li><li id="Lighting/Materials"><span id="menu-item53">Materials </span></li><li id="Lighting/Lighting-maps"><span id="menu-item54">Lighting maps </span></li><li id="Lighting/Light-casters"><span id="menu-item55">Light casters </span></li><li id="Lighting/Multiple-lights"><span id="menu-item58">Multiple lights </span></li><li id="Lighting/Review"><span id="menu-item57">Review </span></li></ol></li><li id="Model-Loading"><span id="menu-item56" class="closed">Model Loading </span><ol id="menu-items-of56" style="display: none;"><li id="Model-Loading/Assimp"><span id="menu-item59">Assimp </span></li><li id="Model-Loading/Mesh"><span id="menu-item60">Mesh </span></li><li id="Model-Loading/Model"><span id="menu-item61">Model </span></li></ol></li><li id="Advanced-OpenGL"><span id="menu-item63" class="closed">Advanced OpenGL </span><ol id="menu-items-of63" style="display:none;"><li id="Advanced-OpenGL/Depth-testing"><span id="menu-item72">Depth testing </span></li><li id="Advanced-OpenGL/Stencil-testing"><span id="menu-item73">Stencil testing </span></li><li id="Advanced-OpenGL/Blending"><span id="menu-item74">Blending </span></li><li id="Advanced-OpenGL/Face-culling"><span id="menu-item77">Face culling </span></li><li id="Advanced-OpenGL/Framebuffers"><span id="menu-item65">Framebuffers </span></li><li id="Advanced-OpenGL/Cubemaps"><span id="menu-item66">Cubemaps </span></li><li id="Advanced-OpenGL/Advanced-Data"><span id="menu-item69">Advanced Data </span></li><li id="Advanced-OpenGL/Advanced-GLSL"><span id="menu-item67">Advanced GLSL </span></li><li id="Advanced-OpenGL/Geometry-Shader"><span id="menu-item68">Geometry Shader </span></li><li id="Advanced-OpenGL/Instancing"><span id="menu-item70">Instancing </span></li><li id="Advanced-OpenGL/Anti-Aliasing"><span id="menu-item75">Anti Aliasing </span></li></ol></li><li id="Advanced-Lighting"><span id="menu-item100" class="closed">Advanced Lighting </span><ol id="menu-items-of100" style="display:none;"><li id="Advanced-Lighting/Advanced-Lighting"><span id="menu-item101">Advanced Lighting </span></li><li id="Advanced-Lighting/Gamma-Correction"><span id="menu-item110">Gamma Correction </span></li><li id="Advanced-Lighting/Shadows"><span id="menu-item102" class="closed">Shadows </span><ol id="menu-items-of102" style="display:none;"><li id="Advanced-Lighting/Shadows/Shadow-Mapping"><span id="menu-item103">Shadow Mapping </span></li><li id="Advanced-Lighting/Shadows/Point-Shadows"><span id="menu-item104">Point Shadows </span></li><li id="Advanced-Lighting/Shadows/CSM"><span id="menu-item105">CSM </span></li></ol></li><li id="Advanced-Lighting/Normal-Mapping"><span id="menu-item106">Normal Mapping </span></li><li id="Advanced-Lighting/Parallax-Mapping"><span id="menu-item107">Parallax Mapping </span></li><li id="Advanced-Lighting/HDR"><span id="menu-item111">HDR </span></li><li id="Advanced-Lighting/Bloom"><span id="menu-item112">Bloom </span></li><li id="Advanced-Lighting/Deferred-Shading"><span id="menu-item108">Deferred Shading </span></li><li id="Advanced-Lighting/SSAO"><span id="menu-item109">SSAO </span></li></ol></li><li id="PBR"><span id="menu-item113" class="closed">PBR </span><ol id="menu-items-of113" style="display:none;"><li id="PBR/Theory"><span id="menu-item114">Theory </span></li><li id="PBR/Lighting"><span id="menu-item115">Lighting </span></li><li id="PBR/IBL"><span id="menu-item116">IBL </span></li></ol></li><li id="In-Practice"><span id="menu-item78" class="closed">In Practice </span><ol id="menu-items-of78" style="display:none;"><li id="In-Practice/Debugging"><span id="menu-item79">Debugging </span></li><li id="In-Practice/Text-Rendering"><span id="menu-item80">Text Rendering </span></li><li id="In-Practice/2D-Game"><span id="menu-item81" class="closed">2D Game </span><ol id="menu-items-of81" style="display:none;"><li id="In-Practice/2D-Game/Breakout"><span id="menu-item82">Breakout </span></li><li id="In-Practice/2D-Game/Setting-up"><span id="menu-item88">Setting up </span></li><li id="In-Practice/2D-Game/Rendering-Sprites"><span id="menu-item83">Rendering Sprites </span></li><li id="In-Practice/2D-Game/Levels"><span id="menu-item84">Levels </span></li><li id="In-Practice/2D-Game/Collisions"><span id="menu-item85" class="closed">Collisions </span><ol id="menu-items-of85" style="display:none;"><li id="In-Practice/2D-Game/Collisions/Ball"><span id="menu-item95">Ball </span></li><li id="In-Practice/2D-Game/Collisions/Collision-detection"><span id="menu-item96">Collision detection </span></li><li id="In-Practice/2D-Game/Collisions/Collision-resolution"><span id="menu-item97">Collision resolution </span></li></ol></li><li id="In-Practice/2D-Game/Particles"><span id="menu-item89">Particles </span></li><li id="In-Practice/2D-Game/Postprocessing"><span id="menu-item90">Postprocessing </span></li><li id="In-Practice/2D-Game/Powerups"><span id="menu-item91">Powerups </span></li><li id="In-Practice/2D-Game/Audio"><span id="menu-item94">Audio </span></li><li id="In-Practice/2D-Game/Render-text"><span id="menu-item92">Render text </span></li><li id="In-Practice/2D-Game/Final-thoughts"><span id="menu-item93">Final thoughts </span></li></ol></li></ol></li><li id="Code-repository"><span id="menu-item99">Code repository </span></li><li id="Offline-book"><span id="menu-item98">Offline book </span></li><li id="About"><span id="menu-item2">About </span></li></ol>           <div id="donate">
                <a href="https://www.patreon.com/learnopengl" target="_blank">
                    <img id="donate_img" src="./Shaders_files/patreon.png">
                </a>
            </div> 
        </div>

        <div id="content" style="display: block;"><h1 id="content-title">Shaders</h1>
<h1 id="content-url" style="display:none;">Getting-started/Shaders</h1>
<p>
  As mentioned in the <a href="http://www.learnopengl.com/#!Getting-started/Hello-Triangle" target="_blank">Hello Triangle</a> tutorial, shaders are little programs that rest on the GPU. These programs are run for each specific section of the graphics pipeline. In a basic sense, shaders are nothing more than programs transforming inputs to outputs. Shaders are also very isolated programs in that they're not allowed to communicate with each other; the only communication they have is via their inputs and outputs.
</p>

<p>
  In the previous tutorial we briefly touched the surface of shaders and how to properly use them. We will now explain shaders, and specifically the OpenGL Shading Language, in a more general fashion.
</p>

<h1>GLSL</h1>
<p>
  Shaders are written in the C-like language GLSL. GLSL is tailored for use with graphics and contains useful features specifically targeted at vector and matrix manipulation.
</p>

<p>
  Shaders always begin with a version declaration, followed by a list of input and output variables, uniforms and its <fun>main</fun> function. Each shader's entry point is at its <fun>main</fun> function where we process any input variables and output the results in its output variables. Don't worry if you don't know what uniforms are, we'll get to those shortly.
</p>

<p>
  A shader typically has the following structure:
</p>

<pre class=" hljs cpp"><code>
<span class="hljs-preprocessor">#version version_number</span>
  
<span class="hljs-keyword">in</span> type in_variable_name;
<span class="hljs-keyword">in</span> type in_variable_name;

<span class="hljs-keyword">out</span> type out_variable_name;
  
<span class="hljs-keyword">uniform</span> type uniform_name;
  
<span class="hljs-keyword">void</span> main()
{
  <span class="hljs-comment">// Process input(s) and do some weird graphics stuff</span>
  ...
  <span class="hljs-comment">// Output processed stuff to output variable</span>
  out_variable_name = weird_stuff_we_processed;
}
</code></pre>

<p>
  When we're talking specifically about the vertex shader each input variable is also known as a <def>vertex attribute</def>. There is a maximum number of vertex attributes we're allowed to declare limited by the hardware. OpenGL guarantees there are always at least 16 4-component vertex attributes available, but some hardware might allow for more which you can retrieve by querying <var>GL_MAX_VERTEX_ATTRIBS</var>:
</p>

<pre class=" hljs cpp"><code>
<span class="hljs-keyword">GLint</span> nrAttributes;
glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Maximum nr of vertex attributes supported: "</span> &lt;&lt; nrAttributes &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
</code></pre>
 
<p>
  This often returns the minimum of <code>16</code> which should be more than enough for most purposes.
</p>

<h2>Types</h2>
<p>
  GLSL has like any other programming language data types for specifying what kind of variable we want to work with. GLSL has most of the default basic types we know from languages like C:  <code>int</code>, <code>float</code>, <code>double</code>, <code>uint</code> and <code>bool</code>. GLSL also features two container types that we'll be using a lot throughout the tutorials, namely <code>vectors</code> and <code>matrices</code>. We'll discuss matrices in a later tutorial.

</p><h3>Vectors</h3>
<p>
  A vector in GLSL is a 1,2,3 or 4 component container for any of the basic types just mentioned.  They can take the following form (<code>n</code> represents the number of components):
</p>
  
  <ul>
    <li><code>vecn</code>: the default vector of <code>n</code> floats.</li>
    <li><code>bvecn</code>: a vector of <code>n</code> booleans.</li>
    <li><code>ivecn</code>: a vector of <code>n</code> integers.</li>
  	<li><code>uvecn</code>: a vector of <code>n</code> unsigned integers.</li>
  	<li><code>dvecn</code>: a vector of <code>n</code> double components.</li>
  </ul>
  
<p>
  Most of the time we will be using the basic <code>vecn</code> since floats are sufficient for most of our purposes.
</p>
  
  <p>
    Components of a vector can be accessed via <code>vec.x</code> where <code>x</code> is the first component of the vector. You can use <code>.x</code>, <code>.y</code>, <code>.z</code> and <code>.w</code> to access their first, second, third and fourth component respectively. GLSL also allows you to use <code>rgba</code> for colors or <code>stpq</code> for texture coordinates, accessing the same components.
  </p>
  
  <p>
    The vector datatype allows for some interesting and flexible component selection called <def>swizzling</def>. Swizzling allows for the following syntax:
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-built_in">vec2</span> someVec;
<span class="hljs-built_in">vec4</span> differentVec = someVec.xyxx;
<span class="hljs-built_in">vec3</span> anotherVec = differentVec.zyw;
<span class="hljs-built_in">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;
</code></pre>
  
<p>
	You can use any combination of up to 4 letters to create a new vector (of the same type) as long as the original vector has those components; it is not allowed to access the <code>.z</code> component of a <code>vec2</code> for example. We can also pass vectors as arguments to different vector constructor calls, reducing the number of arguments required:    
</p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-built_in">vec2</span> vect = <span class="hljs-built_in">vec2</span>(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.7f</span>);
<span class="hljs-built_in">vec4</span> result = <span class="hljs-built_in">vec4</span>(vect, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);
<span class="hljs-built_in">vec4</span> otherResult = <span class="hljs-built_in">vec4</span>(result.xyz, <span class="hljs-number">1.0f</span>);
</code></pre>

<p>
	Vectors are thus a flexible datatype that we can use for all kinds of input and output. Throughout the tutorials you'll see plenty of examples of how we can creatively manage vectors.  
</p>
  
<h2>Ins and outs</h2>
<p>
  Shaders are nice little programs on their own, but they are part of a whole and for that reason we want to have inputs and outputs on the individual shaders so that we can move stuff around. GLSL defined the <code>in</code> and <code>out</code> keywords specifically for that purpose. Each shader can specify inputs and outputs using those keywords and wherever an output variable matches with an input variable of the next shader stage they're passed along. The vertex and fragment shader differ a bit though.
</p>
  
<p>
  The vertex shader should receive some form of input otherwise it would be pretty ineffective. The vertex shader differs in its input, in that it receives its input straight from the vertex data. To define how the vertex data is organized we specify the input variables with location metadata so we can configure the vertex attributes on the CPU. We've seen this in the previous tutorial as <code>layout (location = 0)</code>. The vertex shader thus requires an extra layout specification for its inputs so we can link it with the vertex data.
  </p>
  
<note>
  It is also possible to omit the <code>layout (location = 0)</code> specifier and query for the attribute locations in your OpenGL code via <fun><function id="104">glGetAttribLocation</function></fun>, but I'd prefer to set them in the vertex shader. It is easier to understand and saves you (and OpenGL) some work.
  </note>
  
<p>
  The other exception is that the fragment shader requires a <code>vec4</code> color output variable, since the fragment shaders needs to generate a final output color. If you'd fail to specify an output color in your fragment shader OpenGL will render your object black (or white).
  </p>

<p>
	So if we want to send data from one shader to the other we'd have to declare an output in the sending shader and a similar input in the receiving shader. When the types and the names are equal on both sides OpenGL will link those variables together and then it is possible to send data between shaders (this is done when linking a program object). To show you how this works in practice we're going to alter the shaders from the previous tutorial to let the vertex shader decide the color for the fragment shader.
  </p>

<strong>Vertex shader</strong>
<pre class=" hljs cpp"><code>
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">layout</span> (location = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">vec3</span> position; <span class="hljs-comment">// The position variable has attribute position 0</span>
  
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec4</span> vertexColor; <span class="hljs-comment">// Specify a color output to the fragment shader</span>

<span class="hljs-keyword">void</span> main()
{
    gl_Position = <span class="hljs-built_in">vec4</span>(position, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// See how we directly give a vec3 to vec4's constructor</span>
    vertexColor = <span class="hljs-built_in">vec4</span>(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>); <span class="hljs-comment">// Set the output variable to a dark-red color</span>
}
</code></pre>  
  
<strong>Fragment shader</strong>
<pre class=" hljs cpp"><code>
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">in</span> <span class="hljs-built_in">vec4</span> vertexColor; <span class="hljs-comment">// The input variable from the vertex shader (same name and same type)</span>
  
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec4</span> color;

<span class="hljs-keyword">void</span> main()
{
    color = vertexColor;
} 
</code></pre>
  
<p>
  You can see we declared a <var>vertexColor</var> variable as a <code>vec4</code> output that we set in the vertex shader and we declare a similar <var>vertexColor</var> input in the fragment shader. Since they both have the same type and name, the <var>vertexColor</var> in the fragment shader is linked to the <var>vertexColor</var> in the vertex shader. Because we set the color to a dark-red color in the vertex shader, the resulting fragments should be dark-red as well. The following image shows the output:
  </p>
 
  <img src="./Shaders_files/shaders.png">
  
<p>
   There we go! We just managed to send a value from the vertex shader to the fragment shader. Let's spice it up a bit and see if we can send a color from our application to the fragment shader!
  </p>
  
  <h2>Uniforms</h2>
  <p>
    <def>Uniforms</def> are another way to pass data from our application on the CPU to the shaders on the GPU, but uniforms are slightly different compared to vertex attributes. First of all, uniforms are <def>global</def>. Global, meaning that a uniform variable is unique per shader program object, and can be accessed from any shader at any stage in the shader program. Second, whatever you set the uniform value to, uniforms will keep their values until they're either reset or updated.
  </p>
  
  <p>
    To declare a uniform in GLSL we simply add the <code>uniform</code> keyword to a shader with a type and a name. From that point on we can use the newly declared uniform in the shader. Let's see if this time we can set the color of the triangle via a uniform:
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec4</span> color;
  
<span class="hljs-keyword">uniform</span> <span class="hljs-built_in">vec4</span> ourColor; <span class="hljs-comment">// We set this variable in the OpenGL code.</span>

<span class="hljs-keyword">void</span> main()
{
    color = ourColor;
}   
</code></pre>
  
  <p>
    We declared a uniform <code>vec4</code> <var>ourColor</var> in the fragment shader and set the fragment's output color to the content of this uniform value. Since uniforms are global variables, we can define them in any shader we'd like so no need to go through the vertex shader again to get something to the fragment shader. We're not using this uniform in the vertex shader so there's no need to define it there.
  </p>
  
  <warning>
    If you declare a uniform that isn't used anywhere in your GLSL code the compiler will silently remove the variable from the compiled version which is the cause for several frustrating errors; keep this in mind!
  </warning>
  
  <p>
    The uniform is currently empty; we haven't added any data to the uniform yet so let's try that. We first need to find the index/location of the uniform attribute in our shader. Once we have the index/location of the uniform, we can update its values. Instead of passing a single color to the fragment shader, let's spice things up by gradually changing color over time:
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-keyword">GLfloat</span> timeValue = <function id="47">glfwGetTime</function>();
<span class="hljs-keyword">GLfloat</span> greenValue = (<span class="hljs-built_in">sin</span>(timeValue) / <span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>;
<span class="hljs-keyword">GLint</span> vertexColorLocation = <function id="45">glGetUniformLocation</function>(shaderProgram, <span class="hljs-string">"ourColor"</span>);
<function id="28">glUseProgram</function>(shaderProgram);
<function id="44">glUniform</function>4f(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);
</code></pre>
  
  <p>
    First, we retrieve the running time in seconds via <fun><function id="47">glfwGetTime</function>()</fun>. Then we vary the color in the range of <code>0.0</code> - <code>1.0</code> by using the <fun>sin</fun> function and store the result in <var>greenValue</var>. 
  </p>
  
  <p>
    Then we query for the location of the <var>ourColor</var> uniform using <fun><function id="45">glGetUniformLocation</function></fun>. We supply the shader program and the name of the uniform (that we want to retrieve the location from) to the query function. If <fun><function id="45">glGetUniformLocation</function></fun> returns <code>-1</code>, it could not find the location. Lastly we can set the uniform value using the <fun><function id="44">glUniform</function>4f</fun> function. Note that finding the uniform location does not require you to use the shader program first, but updating a uniform <strong>does</strong> require you to first use the program (by calling <fun><function id="28">glUseProgram</function></fun>), because it sets the uniform on the currently active shader program.
  </p>
  
<note>
<p>
    Because OpenGL is in its core a C library it does not have native support for type overloading, so wherever a function can be called with different types OpenGL defines new functions for each type required; <fun><function id="44">glUniform</function></fun> is a perfect example of this. The function requires a specific postfix for the type of the uniform you want to set. A few of the possible postfixes are:
  </p><ul>
    <li><code>f</code>: the function expects a <code>float</code> as its value</li>  
    <li><code>i</code>: the function expects an <code>int</code> as its value</li>  
  	<li><code>ui</code>: the function expects an <code>unsigned int</code> as its value</li>  
    <li><code>3f</code>: the function expects 3 <code>float</code>s as its value</li> 
    <li><code>fv</code>: the function expects a <code>float</code> vector/array as its value</li> 
  </ul>
  Whenever you want to configure an option of OpenGL simply pick the overloaded function that corresponds with your type. In our case we want to set 4 floats of the uniform individually so we pass our data via <fun><function id="44">glUniform</function>4f</fun> (note that we also could've used the <code>fv</code> version).
<p></p>
</note>
    
 <p>    
   Now what we know how to set the values of uniform variables, we can use them for rendering. If we want the color to gradually change, we want to update this uniform every game loop iteration (so it changes per-frame) otherwise the triangle would maintain a single solid color if we only set it once. So we calculate the <var>greenValue</var> and update the uniform each render iteration:
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-keyword">while</span>(!<function id="14">glfwWindowShouldClose</function>(window))
{
    <span class="hljs-comment">// Check and call events</span>
    <function id="23">glfwPollEvents</function>();

    <span class="hljs-comment">// Render</span>
    <span class="hljs-comment">// Clear the colorbuffer</span>
    <function id="13"><function id="10">glClear</function>Color</function>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);
    <function id="10">glClear</function>(GL_COLOR_BUFFER_BIT);

    <span class="hljs-comment">// Be sure to activate the shader</span>
    <function id="28">glUseProgram</function>(shaderProgram);
  
    <span class="hljs-comment">// Update the uniform color</span>
    <span class="hljs-keyword">GLfloat</span> timeValue = <function id="47">glfwGetTime</function>();
    <span class="hljs-keyword">GLfloat</span> greenValue = (<span class="hljs-built_in">sin</span>(timeValue) / <span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>;
    <span class="hljs-keyword">GLint</span> vertexColorLocation = <function id="45">glGetUniformLocation</function>(shaderProgram, <span class="hljs-string">"ourColor"</span>);
    <function id="44">glUniform</function>4f(vertexColorLocation, <span class="hljs-number">0.0f</span>, greenValue, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);

    <span class="hljs-comment">// Now draw the triangle</span>
    <function id="27">glBindVertexArray</function>(VAO);
    <function id="1">glDrawArrays</function>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
    <function id="27">glBindVertexArray</function>(<span class="hljs-number">0</span>);
}
</code></pre>
  
  <p>
    The code is a relatively straightforward adaptation of the previous code. This time, we update a  uniform value each iteration before drawing the triangle. If you update the uniform correctly you should see the color of your triangle gradually change from green to black and back to green.
  </p>
  
<div class="video paused" onclick="ClickVideo(this)">
  <video width="600" height="450" loop="">
    <source src="video/getting-started/shaders.mp4" type="video/mp4">
    <img src="./Shaders_files/shaders2.png">
  </video>
</div>

  
<p>
    Check out the source code <a href="http://learnopengl.com/code_viewer.php?code=getting-started/shaders-uniform" target="_blank">here</a> if you're stuck.
  </p>
  
<p>
  As you can see, uniforms are a useful tool for setting attributes that might change in render iterations, or for interchanging data between your application and your shaders, but what if we want to set a color for each vertex? In that case we'd have to declare as many uniforms as we have vertices. A better solution would be to include more data in the vertex attributes which is what we're going to do.
  </p>
    
  <h2>More attributes!</h2>
  <p>
    We saw in the previous tutorial how we can fill a VBO, configure vertex attribute pointers and store it all in a VAO. This time, we also want to add color data to the vertex data. We're going to add color data as 3 <code>float</code>s to the <var>vertices</var> array. We assign a red, green and blue color to each of the corners of our triangle respectively:
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-keyword">GLfloat</span> vertices[] = {
    <span class="hljs-comment">// Positions         // Colors</span>
     <span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom Right</span>
    -<span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom Left</span>
     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// Top </span>
};    
</code></pre>
  
<p>
  Since we now have more data to send to the vertex shader, it is necessary to adjust the vertex shader to also receive our color value as a vertex attribute input. Note that we set the location of the <var>color</var> attribute to 1 with the layout specifier:
</p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">layout</span> (location = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">vec3</span> position; <span class="hljs-comment">// The position variable has attribute position 0</span>
<span class="hljs-keyword">layout</span> (location = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">vec3</span> color;	<span class="hljs-comment">// The color variable has attribute position 1</span>
  
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec3</span> ourColor; <span class="hljs-comment">// Output a color to the fragment shader</span>

<span class="hljs-keyword">void</span> main()
{
    gl_Position = <span class="hljs-built_in">vec4</span>(position, <span class="hljs-number">1.0</span>);
    ourColor = color; <span class="hljs-comment">// Set ourColor to the input color we got from the vertex data</span>
}       
</code></pre>
  
  <p>
    Since we no longer use a uniform for the fragment's color, but now use the <var>ourColor</var> output variable we'll have to change the fragment shader as well:
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">in</span> <span class="hljs-built_in">vec3</span> ourColor;
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec4</span> color;
  
<span class="hljs-keyword">void</span> main()
{
    color = <span class="hljs-built_in">vec4</span>(ourColor, <span class="hljs-number">1.0f</span>);
}
</code></pre>
  
<p>
  Because we added another vertex attribute and updated the VBO's memory we have to re-configure the vertex attribute pointers. The updated data in the VBO's memory now looks a bit like this: 
  </p>
  
  <img src="./Shaders_files/vertex_attribute_pointer_interleaved.png" class="clean" alt="Interleaved data of position and color within VBO to be configured wtih &lt;function id=&#39;30&#39;&gt;glVertexAttribPointer&lt;/function&gt;">
    
<p>
  Knowing the current layout we can update the vertex format with <fun><function id="30">glVertexAttribPointer</function></fun>:
</p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-comment">// Position attribute</span>
<function id="30">glVertexAttribPointer</function>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">GL_FLOAT</span>, <span class="hljs-built_in">GL_FALSE</span>, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">GLfloat</span>), (GLvoid*)<span class="hljs-number">0</span>);
<function id="29"><function id="60">glEnable</function>VertexAttribArray</function>(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Color attribute</span>
<function id="30">glVertexAttribPointer</function>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">GL_FLOAT</span>, <span class="hljs-built_in">GL_FALSE</span>, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">GLfloat</span>), (GLvoid*)(<span class="hljs-number">3</span>* <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">GLfloat</span>)));
<function id="29"><function id="60">glEnable</function>VertexAttribArray</function>(<span class="hljs-number">1</span>);
</code></pre>

<p> 
  The first few arguments of <fun><function id="30">glVertexAttribPointer</function></fun> are relatively straightforward. This time we are configuring the vertex attribute on attribute location <code>1</code>. The color values have a size of <code>3</code> <code>float</code>s and we do not normalize the values. 
  </p>
  
  <p>
    Since we now have two vertex attributes we have to re-calculate the <em>stride</em> value. To get the next attribute value (e.g. the next <code>x</code> component of the position  vector) in the data array we have to move <code>6</code> <code>float</code>s to the right, three for the position values and three for the color values. This gives us a stride value of 6 times the size of a <code>float</code> in bytes (= <code>24</code> bytes). <br>
  Also, this time we have to specify an offset. For each vertex, the position vertex attribute is first so we declare an offset of <code>0</code>. The color attribute starts after the position data so the offset is <code>3 * sizeof(GLfloat)</code> in bytes (= <code>12</code> bytes).
</p>
  
<p> 
    Running the application should result in the following image:
</p>
  
  <img src="./Shaders_files/shaders3.png">
  
  <p>
    Check out the source code <a href="http://learnopengl.com/code_viewer.php?code=getting-started/shaders-interpolated" target="_blank">here</a> if you're stuck.
  </p>
  
 <p>
   The image might not be exactly what you would expect, since we only supplied 3 colors, not the huge color palette we're seeing right now. This is all the result of something called <def>fragment interpolation</def> in the fragment shader. When rendering a triangle the rasterization stage usually results in a lot more fragments than vertices originally specified. The rasterizer then determines the positions of each of those fragments based on where they reside on the triangle shape.<br>
   Based on these positions, it <def>interpolates</def> all the fragment shader's input variables. Say for example we have a line where the upper point has a green color and the lower point a blue color. If the fragment shader is run at a fragment that resides around a position at <code>70%</code> of the line its resulting color input attribute would then be a linear combination of green and blue; to be more precise: <code>30%</code> blue and <code>70%</code> green.
  </p>
  
  <p>
    This is exactly what happened at the triangle. We have 3 vertices and thus 3 colors and judging from the triangle's pixels it probably contains around 50000 fragments, where the fragment shader interpolated the colors among those pixels. If you take a good look at the colors you'll see it all makes sense: red to blue first gets to purple and then to blue. Fragment interpolation is applied to all the fragment shader's input attributes.
  </p>   
  
<h1>Our own shader class</h1>
    <p> 
    Writing, compiling and managing shaders can be quite cumbersome. As a final touch on the shader subject we're going to make our life a bit easier by building a shader class that reads shaders from disk, compiles and links them, checks for errors and is easy to use. This also gives you a bit of an idea how we can encapsulate some of the knowledge we learned so far into useful abstract objects.
  </p>
  
  <p>
    We will create the shader class entirely in a header file, mainly for learning purposes and portability. Let's start by adding the required includes and by defining the class structure:
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-preprocessor">#ifndef SHADER_H</span>
<span class="hljs-preprocessor">#define SHADER_H</span>

<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;fstream&gt;</span>
<span class="hljs-preprocessor">#include &lt;sstream&gt;</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
  
<span class="hljs-preprocessor">#include &lt;GL/glew.h&gt;; <span class="hljs-comment">// Include glew to get all the required OpenGL headers</span></span>

<span class="hljs-keyword">class</span> Shader
{
<span class="hljs-keyword">public</span>:
  	<span class="hljs-comment">// The program ID</span>
	<span class="hljs-keyword">GLuint</span> Program;
	<span class="hljs-comment">// Constructor reads and builds the shader</span>
	Shader(<span class="hljs-keyword">const</span> <span class="hljs-keyword">GLchar</span>* vertexPath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">GLchar</span>* fragmentPath);
  	<span class="hljs-comment">// Use the program</span>
  	<span class="hljs-keyword">void</span> Use();
};
  
<span class="hljs-preprocessor">#endif</span>
</code></pre>
  
  <note>
    We used several <def>preprocessor directives</def> at the top of the header file. Using these  little lines of code informs your compiler to only include and compile this header file if it hasn't been included yet, even if multiple files include the shader header. This prevents linking conflicts.
  </note>
  
  <p>
    The shader class holds the ID of the shader program. Its constructor requires the file paths of the source code of the vertex and fragment shader respectively that we can store on disk as simple text files. To add a little extra we also added a utility <fun>Use</fun> function which is rather trivial, but a nice display of how we could ease our life (albeit a little) with home-made classes.
  </p>
  
<h2>Reading from file</h2>
<p>
    We're using C++ filestreams to read the content from the file into several <code>string</code> objects:
</p>
  
<pre class=" hljs cpp"><code>
Shader(<span class="hljs-keyword">const</span> <span class="hljs-keyword">GLchar</span>* vertexPath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">GLchar</span>* fragmentPath)
{
    <span class="hljs-comment">// 1. Retrieve the vertex/fragment source code from filePath</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> vertexCode;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> fragmentCode;
    <span class="hljs-built_in">std</span>::ifstream vShaderFile;
    <span class="hljs-built_in">std</span>::ifstream fShaderFile;
    <span class="hljs-comment">// ensures ifstream objects can throw exceptions:</span>
    vShaderFile.exceptions(<span class="hljs-built_in">std</span>::ifstream::badbit);
    fShaderFile.exceptions(<span class="hljs-built_in">std</span>::ifstream::badbit);
    <span class="hljs-keyword">try</span> 
    {
        <span class="hljs-comment">// Open files</span>
        vShaderFile.open(vertexPath);
        fShaderFile.open(fragmentPath);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stringstream</span> vShaderStream, fShaderStream;
        <span class="hljs-comment">// Read file's buffer contents into streams</span>
        vShaderStream &lt;&lt; vShaderFile.rdbuf();
        fShaderStream &lt;&lt; fShaderFile.rdbuf();		
        <span class="hljs-comment">// close file handlers</span>
        vShaderFile.close();
        fShaderFile.close();
        <span class="hljs-comment">// Convert stream into GLchar array</span>
        vertexCode = vShaderStream.str();
        fragmentCode = fShaderStream.str();		
    }
    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">std</span>::ifstream::failure e)
    {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">GLchar</span>* vShaderCode = vertexCode.c_str();
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">GLchar</span>* fShaderCode = fragmentCode.c_str();
    [...]
</code></pre> 
  
  <p>
    Next we need to compile and link the shaders. Note that we're also reviewing if compilation/linking failed and if so, print the compile-time errors which is extremely useful when debugging (you are going to need those error logs eventually):
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-comment">// 2. Compile shaders</span>
<span class="hljs-keyword">GLuint</span> vertex, fragment;
<span class="hljs-keyword">GLint</span> success;
<span class="hljs-keyword">GLchar</span> infoLog[<span class="hljs-number">512</span>];
   
<span class="hljs-comment">// Vertex Shader</span>
vertex = <function id="37">glCreateShader</function>(GL_VERTEX_SHADER);
<function id="42">glShaderSource</function>(vertex, <span class="hljs-number">1</span>, &amp;vShaderCode, NULL);
<function id="38">glCompileShader</function>(vertex);
<span class="hljs-comment">// Print compile errors if any</span>
<function id="39">glGetShaderiv</function>(vertex, GL_COMPILE_STATUS, &amp;success);
<span class="hljs-keyword">if</span>(!success)
{
    <function id="40">glGetShaderInfoLog</function>(vertex, <span class="hljs-number">512</span>, NULL, infoLog);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
};
  
<span class="hljs-comment">// Similiar for Fragment Shader</span>
[...]
  
<span class="hljs-comment">// Shader Program</span>
<span class="hljs-keyword">this</span>-&gt;Program = <function id="36">glCreateProgram</function>();
<function id="34">glAttachShader</function>(<span class="hljs-keyword">this</span>-&gt;Program, vertex);
<function id="34">glAttachShader</function>(<span class="hljs-keyword">this</span>-&gt;Program, fragment);
<function id="35">glLinkProgram</function>(<span class="hljs-keyword">this</span>-&gt;Program);
<span class="hljs-comment">// Print linking errors if any</span>
<function id="41">glGetProgramiv</function>(<span class="hljs-keyword">this</span>-&gt;Program, GL_LINK_STATUS, &amp;success);
<span class="hljs-keyword">if</span>(!success)
{
    glGetProgramInfoLog(<span class="hljs-keyword">this</span>-&gt;Program, <span class="hljs-number">512</span>, NULL, infoLog);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
  
<span class="hljs-comment">// Delete the shaders as they're linked into our program now and no longer necessery</span>
<function id="46">glDeleteShader</function>(vertex);
<function id="46">glDeleteShader</function>(fragment);
</code></pre> 

  <p>
    And as a finishing touch we will also implement the <fun>Use</fun> function:
  </p>
  
<pre class=" hljs cpp"><code>
<span class="hljs-keyword">void</span> Use() { <function id="28">glUseProgram</function>(<span class="hljs-keyword">this</span>-&gt;Program); }  
</code></pre>
  
  <p>
    And there we have it, a completed shader class. Using the shader class is fairly easy; we create a shader object once and from that point on simply start using it:
  </p>
  
<pre class=" hljs cpp"><code>
Shader ourShader(<span class="hljs-string">"path/to/shaders/shader.vs"</span>, <span class="hljs-string">"path/to/shaders/shader.frag"</span>);
...
<span class="hljs-keyword">while</span>(...)
{
    ourShader.Use();
    <function id="44">glUniform</function>1f(<function id="45">glGetUniformLocation</function>(ourShader.Program, <span class="hljs-string">"someUniform"</span>), <span class="hljs-number">1.0f</span>);
    DrawStuff();
}
</code></pre>
    
<p>
  Here we stored the vertex and fragment shader source code in two files called <code>shader.vs</code> and <code>shader.frag</code>. You're free to name your shader files in any way you like; I personally find the extensions <code>.vs</code> and <code>.frag</code> quite intuitive.
</p>
  
  <p>
    Source code of the <a href="http://learnopengl.com/code_viewer.php?code=getting-started/shaders-using-object" target="_blank">program with new shader class</a>, the <a href="http://learnopengl.com/code_viewer.php?type=header&amp;code=shader" target="_blank">shader class</a>, the <a href="http://learnopengl.com/code_viewer.php?type=vertex&amp;code=getting-started/basic" target="_blank">vertex shader</a> and the <a href="http://learnopengl.com/code_viewer.php?type=fragment&amp;code=getting-started/basic" target="_blank">fragment shader</a>.
  </p>

<h1>Exercises</h1>
  <ol>
    <li>Adjust the vertex shader so that the triangle is upside down: <a href="http://learnopengl.com/code_viewer.php?code=getting-started/shaders-exercise1" target="_blank">solution</a>.</li>
    <li>Specify a horizontal offset via a uniform and move the triangle to the right side of the screen in the vertex shader using this offset value: <a href="http://learnopengl.com/code_viewer.php?code=getting-started/shaders-exercise2" target="_blank">solution</a>.</li>
    <li>Output the vertex position to the fragment shader using the <code>out</code> keyword and set the fragment's color equal to this vertex position (see how even the vertex position values are interpolated across the triangle). Once you managed to do this; try to answer the following question: why is the bottom-left side of our triangle black?: <a href="http://learnopengl.com/code_viewer.php?code=getting-started/shaders-exercise3" target="_blank">solution</a>.</li>
  </ol>
  </div>
        
        <div id="hover">
            HI
        </div>
    <div id="disqus_thread" style="display: block;"><iframe id="dsq-app4" name="dsq-app4" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./Shaders_files/saved_resource.html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 8856px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>

    


</div> <!-- Closed Container div -->

<iframe style="display: none;" src="./Shaders_files/saved_resource(1).html"></iframe></body></html>