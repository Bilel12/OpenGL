<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0059)http://nehe.gamedev.net/article/glsl_an_introduction/25007/ -->
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>NeHe Productions: GLSL: An Introduction</title>

    <link rel="stylesheet" type="text/css" href="./NeHe Productions_ GLSL_ An Introduction_files/public_base.css">
    <link type="text/css" rel="stylesheet" href="./NeHe Productions_ GLSL_ An Introduction_files/shThemeMidnight.css">
    
    <link rel="alternate" type="application/atom+xml" title="Atom feed" href="http://nehe.gamedev.net/atom/">
    <link rel="alternate" type="application/rss+xml" title="RSS feed" href="http://nehe.gamedev.net/rss/">
    
    <meta name="author" content="Luke Benstead + Carsten Haubold">
    <meta name="description" content="OpenGL Tutorials, Demos, Games and More...">
    <meta name="keywords" content="opengl, tutorial, article, demo, game, blend, texturemap, lighting, contest, 3D">

    
    

    




    
    
    
        <script src="./NeHe Productions_ GLSL_ An Introduction_files/cb=gapi.loaded_1" async=""></script><script src="./NeHe Productions_ GLSL_ An Introduction_files/cb=gapi.loaded_0" async=""></script><script type="text/javascript" async="" src="./NeHe Productions_ GLSL_ An Introduction_files/plusone.js.download" gapi_processed="true"></script><script id="facebook-jssdk" src="./NeHe Productions_ GLSL_ An Introduction_files/all.js.download"></script><script async="" type="text/javascript" src="./NeHe Productions_ GLSL_ An Introduction_files/gpt.js.download"></script><script type="text/javascript">
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
        (function() {
        var gads = document.createElement('script');
        gads.async = true;
        gads.type = 'text/javascript';
        var useSSL = 'https:' == document.location.protocol;
        gads.src = (useSSL ? 'https:' : 'http:') + 
        '//www.googletagservices.com/tag/js/gpt.js';
        var node = document.getElementsByTagName('script')[0];
        node.parentNode.insertBefore(gads, node);
        })();
        </script>

        <script type="text/javascript">
        googletag.cmd.push(function() {
        googletag.defineSlot('/1004699/Leaderboard_NeHe', [728, 90], 'div-gpt-ad-1327940144417-0').addService(googletag.pubads());
        googletag.defineSlot('/1004699/Skyscraper_NeHe', [160, 600], 'div-gpt-ad-1327940144417-1').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
        });
        </script>
    
    
  <script src="./NeHe Productions_ GLSL_ An Introduction_files/pubads_impl_104.js.download" async=""></script><style type="text/css">.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:"lucida grande", tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}.fb_link img{border:none}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}
.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}.fb_reset .fb_dialog_legacy{overflow:visible}.fb_dialog_advanced{padding:10px;-moz-border-radius:8px;-webkit-border-radius:8px;border-radius:8px}.fb_dialog_content{background:#fff;color:#333}.fb_dialog_close_icon{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;_background-image:url(https://static.xx.fbcdn.net/rsrc.php/v3/yL/r/s816eWC-2sl.gif);cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px}.fb_dialog_mobile .fb_dialog_close_icon{top:5px;left:5px;right:auto}.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}.fb_dialog_close_icon:hover{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent;_background-image:url(https://static.xx.fbcdn.net/rsrc.php/v3/yL/r/s816eWC-2sl.gif)}.fb_dialog_close_icon:active{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent;_background-image:url(https://static.xx.fbcdn.net/rsrc.php/v3/yL/r/s816eWC-2sl.gif)}.fb_dialog_loader{background-color:#f6f7f9;border:1px solid #606060;font-size:24px;padding:20px}.fb_dialog_top_left,.fb_dialog_top_right,.fb_dialog_bottom_left,.fb_dialog_bottom_right{height:10px;width:10px;overflow:hidden;position:absolute}.fb_dialog_top_left{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/ye/r/8YeTNIlTZjm.png) no-repeat 0 0;left:-10px;top:-10px}.fb_dialog_top_right{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/ye/r/8YeTNIlTZjm.png) no-repeat 0 -10px;right:-10px;top:-10px}.fb_dialog_bottom_left{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/ye/r/8YeTNIlTZjm.png) no-repeat 0 -20px;bottom:-10px;left:-10px}.fb_dialog_bottom_right{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/ye/r/8YeTNIlTZjm.png) no-repeat 0 -30px;right:-10px;bottom:-10px}.fb_dialog_vert_left,.fb_dialog_vert_right,.fb_dialog_horiz_top,.fb_dialog_horiz_bottom{position:absolute;background:#525252;filter:alpha(opacity=70);opacity:.7}.fb_dialog_vert_left,.fb_dialog_vert_right{width:10px;height:100%}.fb_dialog_vert_left{margin-left:-10px}.fb_dialog_vert_right{right:0;margin-right:-10px}.fb_dialog_horiz_top,.fb_dialog_horiz_bottom{width:100%;height:10px}.fb_dialog_horiz_top{margin-top:-10px}.fb_dialog_horiz_bottom{bottom:0;margin-bottom:-10px}.fb_dialog_iframe{line-height:0}.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #365899;color:#fff;font-size:14px;font-weight:bold;margin:0}.fb_dialog_content .dialog_title>span{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/yd/r/Cou7n-nqK52.gif) no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}body.fb_hidden{-webkit-transform:none;height:100%;margin:0;overflow:visible;position:absolute;top:-10000px;left:0;width:100%}.fb_dialog.fb_dialog_mobile.loading{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/ya/r/3rhSv5V8j3o.gif) white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}.fb_dialog.fb_dialog_mobile.loading.centered{width:auto;height:auto;min-height:initial;min-width:initial;background:none}.fb_dialog.fb_dialog_mobile.loading.centered #fb_dialog_loader_spinner{width:100%}.fb_dialog.fb_dialog_mobile.loading.centered .fb_dialog_content{background:none}.loading.centered #fb_dialog_loader_close{color:#fff;display:block;padding-top:20px;clear:both;font-size:18px}#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .45);position:absolute;bottom:0;left:0;right:0;top:0;width:100%;min-height:100%;z-index:10000}#fb-root #fb_dialog_ipad_overlay.hidden{display:none}.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}.fb_dialog_content .dialog_header{-webkit-box-shadow:white 0 1px 1px -1px inset;background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#738ABA), to(#2C4987));border-bottom:1px solid;border-color:#1d4088;color:#fff;font:14px Helvetica, sans-serif;font-weight:bold;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}.fb_dialog_content .dialog_header table{-webkit-font-smoothing:subpixel-antialiased;height:43px;width:100%}.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px}.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px}.fb_dialog_content .touchable_button{background:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#4966A6), color-stop(.5, #355492), to(#2A4887));border:1px solid #29487d;-webkit-background-clip:padding-box;-webkit-border-radius:3px;-webkit-box-shadow:rgba(0, 0, 0, .117188) 0 1px 1px inset, rgba(255, 255, 255, .167969) 0 1px 0;display:inline-block;margin-top:3px;max-width:85px;line-height:18px;padding:4px 12px;position:relative}.fb_dialog_content .dialog_header .touchable_button input{border:none;background:none;color:#fff;font:12px Helvetica, sans-serif;font-weight:bold;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}.fb_dialog_content .dialog_content{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #555;border-bottom:0;border-top:0;height:150px}.fb_dialog_content .dialog_footer{background:#f6f7f9;border:1px solid #555;border-top-color:#ccc;height:40px}#fb_dialog_loader_close{float:left}.fb_dialog.fb_dialog_mobile .fb_dialog_close_button{text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}#fb_dialog_loader_spinner{animation:rotateSpinner 1.2s linear infinite;background-color:transparent;background-image:url(https://static.xx.fbcdn.net/rsrc.php/v3/yD/r/t-wz8gw1xG1.png);background-repeat:no-repeat;background-position:50% 50%;height:24px;width:24px}@keyframes rotateSpinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.fb_iframe_widget{display:inline-block;position:relative}.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}.fb_iframe_widget iframe{position:absolute}.fb_iframe_widget_fluid_desktop,.fb_iframe_widget_fluid_desktop span,.fb_iframe_widget_fluid_desktop iframe{max-width:100%}.fb_iframe_widget_fluid_desktop iframe{min-width:220px;position:relative}.fb_iframe_widget_lift{z-index:1}.fb_hide_iframes iframe{position:relative;left:-10000px}.fb_iframe_widget_loader{position:relative;display:inline-block}.fb_iframe_widget_fluid{display:inline}.fb_iframe_widget_fluid span{width:100%}.fb_iframe_widget_loader iframe{min-height:32px;z-index:2;zoom:1}.fb_iframe_widget_loader .FB_Loader{background:url(https://static.xx.fbcdn.net/rsrc.php/v3/y9/r/jKEcVPZFk-2.gif) no-repeat;height:32px;width:32px;margin-left:-16px;position:absolute;left:50%;z-index:4}</style></head>

  <body>
    
<div id="fb-root" class=" fb_reset"><div style="position: absolute; top: -10000px; height: 0px; width: 0px;"><div></div></div><div style="position: absolute; top: -10000px; height: 0px; width: 0px;"><div><iframe name="fb_xdm_frame_http" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" id="fb_xdm_frame_http" aria-hidden="true" title="Facebook Cross Domain Communication Frame" tabindex="-1" src="./NeHe Productions_ GLSL_ An Introduction_files/fTmIQU3LxvB.html" style="border: none;"></iframe><iframe name="fb_xdm_frame_https" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" id="fb_xdm_frame_https" aria-hidden="true" title="Facebook Cross Domain Communication Frame" tabindex="-1" src="./NeHe Productions_ GLSL_ An Introduction_files/fTmIQU3LxvB(1).html" style="border: none;"></iframe></div></div></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_GB/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>




    <table cellpadding="0" cellspacing="0" border="0" id="layout_table">
    <tbody><tr><td>
        <div id="header">
                <a href="http://nehe.gamedev.net/"><img class="logo" src="./NeHe Productions_ GLSL_ An Introduction_files/nehe.png" border="0" alt="Nehe"></a>
        </div>            
    </td></tr>
    <tr><td colspan="2">
            
<div class="navbar">
    <a href="http://nehe.gamedev.net/">HOME</a>
    <a href="http://twitter.com/#!/nehegl">TWITTER</a>  
    <a href="http://www.facebook.com/pages/NeHe/300582493323181">FACEBOOK</a>     
    <a href="http://nehe.gamedev.net/rss/">RSS</a>    
    <a href="http://nehe.gamedev.net/atom/">ATOM</a>    
    <a href="http://www.gamedev.net/forum/27-nehe-productions/page__forum_title__NeHe+Productions">FORUM</a>    
</div>
    
    </td></tr>
    <tr>
        <td class="col1">

            
<div id="article_container">


<h1 class="article-header">GLSL: An Introduction</h1>
<div class="social-media">
<!-- Place this tag where you want the +1 button to render -->
<div id="___plusone_0" style="text-indent: 0px; margin: 0px; padding: 0px; background: transparent; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block; width: 120px; height: 20px;"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="position: static; top: 0px; width: 120px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 20px;" tabindex="0" vspace="0" width="100%" id="I0_1478285112785" name="I0_1478285112785" src="./NeHe Productions_ GLSL_ An Introduction_files/fastbutton.html" data-gapiattached="true" title="+1"></iframe></div>
<div class="fb-like fb_iframe_widget" data-send="false" data-layout="button_count" data-width="60" data-show-faces="false" data-colorscheme="dark" data-font="arial" fb-xfbml-state="rendered" fb-iframe-plugin-query="app_id=&amp;color_scheme=dark&amp;container_width=0&amp;font=arial&amp;href=http%3A%2F%2Fnehe.gamedev.net%2Farticle%2Fglsl_an_introduction%2F25007%2F&amp;layout=button_count&amp;locale=en_GB&amp;sdk=joey&amp;send=false&amp;show_faces=false&amp;width=60"><span style="vertical-align: bottom; width: 78px; height: 20px;"><iframe name="f19e9f95d56f19c" width="60px" height="1000px" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" title="fb:like Facebook Social Plugin" src="./NeHe Productions_ GLSL_ An Introduction_files/like.html" style="border: none; visibility: visible; width: 78px; height: 20px;" class=""></iframe></span></div>
</div>
<div style="clear:both;"></div>
<p><strong><span style="text-decoration: underline;">What Is GLSL?</span></strong></p>
<p>GLSL (GLslang) is a short term for the official OpenGL Shading Language. GLSL is a C/C++ similar high level programming language for several parts of the graphic card. With GLSL you can code (right up to) short programs, called shaders, which are executed on the GPU.</p>
<p><strong><span style="text-decoration: underline;">Why Shaders?</span></strong></p>
<p>Until DirectX 8 hardware (GeForce 2 and lower, Radoen 7000 and lower) the graphic pipeline could only be configured, but not be programmed. For example there is the OpenGL lighting model with ambient, diffuse, specular and emissive lighting. This model is mainly used but there are many other models for lighting. In fixed-function OpenGL only this lighting model could be used, no other. With Shaders you are able to write your own lighting model. But thats only one feature of shaders. There are thousands of other really nice possibilities: Shadows, Environment Mapping, Per-Pixel Lighting, Bump Mapping, Parallax Bump Mapping, HDR, and much more!</p>
<p><strong><span style="text-decoration: underline;">Why GLSL?</span></strong></p>
<p>Shaders are available in OpenGL till 2002 through ARB_vertex_program and ARB_fragment_program extension. But with those extensions you are only able to use assembly shaders. Because of the growing complexity of lighting and shading models assembly shaders are hard to use. GLSL is a high-level shading language, which means that you can write your shader in C/C++ style. This makes shader development much easier!</p>
<p><strong><span style="text-decoration: underline;">What Is The Difference Between Fixed Function Pipeline And GLSL?</span></strong></p>
<p>There are two types of shaders in GLSL: vertex shaders and fragment shaders.</p>
<p><strong><span style="text-decoration: underline;">Vertex Shader</span></strong></p>
<p>A vertex shader operates on every vertex. So if you call glVertex* (or glDrawArrays, ) the vertex shader is executed for each vertex. If you use a vertex shader you have nearly full control over what is happening with each vertex. But if you use a vertex shader ALL Per-Vertex operations of the fixed function OpenGL pipeline are replaced (see Figure 1):</p>
<ul>
<ul>Vertex Transformation</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>Normal Transformation, Normalization and Rescaling</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>Lighting</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>Texture Coordinate Generation and Transformation</ul>
</ul>
<p>&nbsp;</p>
<p>For a full overview what a vertex shader replaces and what it does not replace please see reference [1], page 41. So if you want to use a vertex shader you HAVE to do all these things above on your own (of course, only if you need it :-)</p>
<p><strong><span style="text-decoration: underline;">Fragment Shader</span></strong></p>
<p>A fragment shader operates on every fragment which is produced by rasterization. With fragment shader you have nearly full control over what is happening with each fragment. But just like a vertex shader, a fragment shader replaces ALL Per-Fragment operations of the fixed function OpenGL pipeline (see Figure 1):</p>
<ul>
<ul>Texture access and application (Texture environments)</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>Fog</ul>
</ul>
<p>&nbsp;</p>
<p>For a full overview what a fragment shader replaces and what it does not replace please see reference [1], page 43. Using a fragment shader is just like using a vertex shader, because you HAVE to do all these things above on your own (of course, only if you need it).</p>
<center><img src="./NeHe Productions_ GLSL_ An Introduction_files/image1.jpg" alt="" border="1"><br> Figure 1, OpenGL 1.5 fixed function pipeline [1]</center>
<p><strong><span style="text-decoration: underline;">What Does GLSL Look Like?</span></strong></p>
<p>As mentioned above there are 2 types of shaders, a vertex shader and a fragment shader. Each shader type has other inputs and outputs.</p>
<p><strong><span style="text-decoration: underline;">Data Types In GLSL</span></strong></p>
<p>There are four main types: float, int, bool and sampler. For the first three types, vector types are available:</p>
<pre>vec2, vec3, vec4			2D, 3D and 4D floating point vector
ivec2, ivec3, ivec4			2D, 3D and 4D integer vector
bvec2, bvec3, bvec4			2D, 3D and 4D boolean vectors
</pre>
<p>For floats here are also matrix types:</p>
<pre>mat2, mat3, mat4			2x2, 3x3, 4x4 floating point matrix
</pre>
<p>Samplers are types representing textures. They are used for texture sampling. Sampler types have to be uniform. They are not allowed to be declared as a non-uniform type. Here are the different sampler types:</p>
<pre>sampler1D, sampler2D, sampler3D		1D, 2D and 3D texture
samplerCube				Cube Map texture
sampler1Dshadow, sampler2Dshadow	1D and 2D depth-component texture
</pre>
<p><strong><span style="text-decoration: underline;">About Attributes, Uniforms And Varyings</span></strong></p>
<p>There are three types of inputs and outputs in a shader: uniforms, attributes and varyings.</p>
<p>Uniforms are values which do not change during a rendering, for example the light position or the light color. Uniforms are available in vertex and fragment shaders. Uniforms are read-only.</p>
<p>Attributes are only available in vertex shader and they are input values which change every vertex, for example the vertex position or normals. Attributes are read-only.</p>
<p>Varyings are used for passing data from a vertex shader to a fragment shader. Varyings are (perspective correct) interpolated across the primitive. Varyings are read-only in fragment shader but are read- and writeable in vertex shader (but be careful, reading a varying type before writing to it will return an undefined value). If you want to use varyings you have to declare the same varying in your vertex shader and in your fragment shader.</p>
<p>All uniform, attribute and varying types HAVE to be global. You are not allowed to specify a uniform/attribute/varying type in a function or a void.</p>
<p><strong><span style="text-decoration: underline;">Built-In Types</span></strong></p>
<p>GLSL has some built-in attributes in a vertex shader:</p>
<pre>gl_Vertex				4D vector representing the vertex position
gl_Normal				3D vector representing the vertex normal
gl_Color				4D vector representing the vertex color
gl_MultiTexCoordX			4D vector representing the texture coordinate of texture unit X
</pre>
<p>There are some other built-in attributes, see reference [2], page 41 for a full list.</p>
<p>GLSL also has some built-in uniforms:</p>
<pre>gl_ModelViewMatrix			4x4 Matrix representing the model-view matrix.
gl_ModelViewProjectionMatrix		4x4 Matrix representing the model-view-projection matrix.
gl_NormalMatrix				3x3 Matrix representing the inverse transpose model-view matrix.
					This matrix is used for normal transformation.
</pre>
<p>There are some other built-in uniforms, like lighting states. See reference [2], page 42 for a full list.</p>
<p><strong><span style="text-decoration: underline;">GLSL Built-In Varyings:</span></strong></p>
<pre>gl_FrontColor				4D vector representing the primitives front color
gl_BackColor				4D vector representing the primitives back color
gl_TexCoord[X]				4D vector representing the Xth texture coordinate
</pre>
<p>There are some other built-in varyings. See reference [2], page 44 for a full list.</p>
<p>And last but not least there are some built-in types which are used for shader output:</p>
<pre>gl_Position				4D vector representing the final processed vertex position. Only 
					available in vertex shader.
gl_FragColor				4D vector representing the final color which is written in the frame 
					buffer. Only available in fragment shader.
gl_FragDepth				float representing the depth which is written in the depth buffer.
					Only available in fragment shader.
</pre>
<p>The importance of built-in types is that they are mapped to the OpenGL states. For example if you call glLightfv(GL_LIGHT0, GL_POSITION, my_light_position) this value is available as a uniform using gl_LightSource[0].position in a vertex and/or fragment shader.</p>
<p><strong><span style="text-decoration: underline;">Generic Types</span></strong></p>
<p>You are also able to specify your own attributes, uniforms and varyings. For example if you want to pass a 3D tangent vector for each vertex from your application to the vertex shader you can specify a Tangent attribute:</p>
<pre>attribute vec3 Tangent;
</pre>
<p>Here are some other examples:</p>
<div><div id="highlighter_968343" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">uniform sampler2D my_color_texture;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">uniform mat4 my_texture_matrix;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="cpp plain">varying vec3 vertex_to_light_vector;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">varying vec3 vertex_to_eye_vector;</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="cpp plain">attribute vec3 tangent;</code></div><div class="line number8 index7 alt1"><code class="cpp plain">attribute vec3 binormal;</code></div></div></td></tr></tbody></table></div></div>
<p><strong><span style="text-decoration: underline;">Language Details</span></strong></p>
<p>GLSL is quite similar to C/C++ but there are some minor differences. See reference [1], page 57 for ANSI C features which are not supported in GLSL.</p>
<p>Additionally GLSL has the following features/restrictions:</p>
<p>GLSL is 100% type safe. You are not allowed to assign an integer to a float without casting (by constructor):</p>
<div><div id="highlighter_451584" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">float</code> <code class="cpp plain">my_float = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Wont Work! 1 Is An Integer!</code></div><div class="line number2 index1 alt1"><code class="cpp color1 bold">float</code> <code class="cpp plain">my_new_float = 1.0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Will Work!</code></div></div></td></tr></tbody></table></div></div>
<p>Casts have to be done using constructors. For example this wont work:</p>
<div><div id="highlighter_255213" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">vec2 my_vec;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">ivec2 my_int_vec;</code></div><div class="line number3 index2 alt2"><code class="cpp plain">my_vec2 = (vec2)my_int_vec;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Wont Work Because No Constructor Is Used!</code></div><div class="line number4 index3 alt1"><code class="cpp plain">my_vec2 = vec2(my_int_vec);&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Will Work!</code></div></div></td></tr></tbody></table></div></div>
<p>Vectors and matrices can be only be filled with user-data using constructors:</p>
<div><div id="highlighter_755347" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">vec3 my_vec = vec3(1.0, 1.0, 1.0);</code></div><div class="line number2 index1 alt1"><code class="cpp plain">mat3 my_mat = mat3(1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0);</code></div></div></td></tr></tbody></table></div></div>
<p>Vector multiplication is component-wise:</p>
<div><div id="highlighter_836677" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">vec3 my_vec1 = vec3(5.0, 1.0, 0.0);</code></div><div class="line number2 index1 alt1"><code class="cpp plain">vec3 my_vec2 = vec3(1.0, 3.0, 4.0);</code></div><div class="line number3 index2 alt2"><code class="cpp plain">vec3 product = my_vec1 * my_vec2;&nbsp;&nbsp; </code><code class="cpp comments">// Will Return This Vector: (5.0, 3.0, 0.0)</code></div></div></td></tr></tbody></table></div></div>
<p>Vector with matrix multiplication is also available.<br> Matrix * Vector will threat the vector as a column-vector (OpenGL standard)<br> Vector * Matrix will threat the vector as a row-vector (DirectX standard)<br> For example a vertex is normally transformed in this way:</p>
<div><div id="highlighter_304760" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex</code></div></div></td></tr></tbody></table></div></div>
<p>This will simply transform the vertex position by the model-view-projection matrix.</p>
<p>There are also many built-in function which can (and should) be used:</p>
<pre>dot		a simple dot product
cross		a simple cross product
texture2D	used for sampling a texture
normalize	normalize a vector
clamp		clamping a vector to a minimum and a maximum
</pre>
<p>For a full list of built-in functions see reference [2], page 46.</p>
<p>Each shader must have a main() void. This void is called if the shader is executed.</p>
<p><strong><span style="text-decoration: underline;">Shader Examples</span></strong></p>
<p>So, up to now we have heard a lot concerning GLSL. But how does a shader look like. Here are some simple examples:</p>
<p><strong><span style="text-decoration: underline;">Ambient Shader</span></strong></p>
<p>The ambient shader surely is the simplest shader available. Each rendered pixel has one specific color:</p>
<p><em>Vertex Shader:</em></p>
<div><div id="highlighter_872649" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">main()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Transforming The Vertex</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p><em>Fragment Shader:</em></p>
<div><div id="highlighter_381718" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">Void main()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Setting Each Pixel To Red</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</code></div><div class="line number5 index4 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p><strong><span style="text-decoration: underline;">Diffuse Shader</span></strong></p>
<p>The diffuse lighting model is one common used lighting model. Its a little bit harder to implement:</p>
<p><em>Vertex Shader:</em></p>
<div><div id="highlighter_196331" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">varying vec3 normal;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">varying vec3 vertex_to_light_vector;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="cpp keyword bold">void</code> <code class="cpp plain">main()</code></div><div class="line number5 index4 alt2"><code class="cpp plain">{</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Transforming The Vertex</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;</code></div><div class="line number8 index7 alt1">&nbsp;</div><div class="line number9 index8 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Transforming The Normal To ModelView-Space</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">normal = gl_NormalMatrix * gl_Normal; </code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Transforming The Vertex Position To ModelView-Space</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">vec4 vertex_in_modelview_space = gl_ModelViewMatrx * gl_Vertex;</code></div><div class="line number14 index13 alt1">&nbsp;</div><div class="line number15 index14 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Calculating The Vector From The Vertex Position To The Light Position</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">vertex_to_light_vector = vec3(gl_LightSource[0].position  vertex_in_modelview_space);</code></div><div class="line number17 index16 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p><em>Fragment Shader:</em></p>
<div><div id="highlighter_42870" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">varying vec3 normal;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">varying vec3 vertex_to_light_vector;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="cpp keyword bold">void</code> <code class="cpp plain">main()</code></div><div class="line number5 index4 alt2"><code class="cpp plain">{</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Defining The Material Colors</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">const</code> <code class="cpp plain">vec4 AmbientColor = vec4(0.1, 0.0, 0.0, 1.0);</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">const</code> <code class="cpp plain">vec4 DiffuseColor = vec4(1.0, 0.0, 0.0, 1.0);</code></div><div class="line number9 index8 alt2">&nbsp;</div><div class="line number10 index9 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Scaling The Input Vector To Length 1</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">vec3 normalized_normal = normalize(normal);</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">vec3 normalized_vertex_to_light_vector = normalize(vertex_to_light_vector);</code></div><div class="line number13 index12 alt2">&nbsp;</div><div class="line number14 index13 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Calculating The Diffuse Term And Clamping It To [0;1]</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp color1 bold">float</code> <code class="cpp plain">DiffuseTerm = clamp(dot(normal, vertex_to_light_vector), 0.0, 1.0);</code></div><div class="line number16 index15 alt1">&nbsp;</div><div class="line number17 index16 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Calculating The Final Color</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">gl_FragColor = AmbientColor + DiffuseColor * DiffuseTerm;</code></div><div class="line number19 index18 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p><strong><span style="text-decoration: underline;">Texture Mapping Shader</span></strong></p>
<p>This is a simple shader for texture mapping.</p>
<p><em>Vertex Shader</em></p>
<p>varying vec2 texture_coordinate;</p>
<div><div id="highlighter_918783" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">main()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Transforming The Vertex</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;</code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Passing The Texture Coordinate Of Texture Unit 0 To The Fragment Shader</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">texture_coordinate = vec2(gl_MultiTexCoord0);</code></div><div class="line number8 index7 alt1"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p><em>Fragment Shader</em></p>
<p>varying vec2 texture_coordinate; uniform sampler2D my_color_texture;</p>
<div><div id="highlighter_726765" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">main()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Sampling The Texture And Passing It To The Frame Buffer</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">gl_FragColor = texture2D(my_color_texture, texture_coordinate);</code></div><div class="line number5 index4 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p><strong><span style="text-decoration: underline;">GLSL API  How To Use GLSL In Your OpenGL Application</span></strong></p>
<p>All right, we heard how to write shaders and what they are good for. But how do we use them in our OpenGL application?</p>
<p>GLSL is available right now through 4 extensions:</p>
<pre>GL_ARB_shader_objects
GL_ARB_shading_language_100
GL_ARB_vertex_shader
GL_ARB_fragment_shader
</pre>
<p>All extensions documents are available in the OpenGL extension registry, see reference [3].</p>
<p>GLSL is very similar to C/C++. So if you want to use a GLSL shader you have to do the following steps:</p>
<ul>
<ul>Passing the shader source to a shader object</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>Compiling the shader source</ul>
</ul>
<p>&nbsp;</p>
<ul>Linking shaders to one program object</ul>
<p>A shader object represents your source code. You are able to pass your source code to a shader object and compile the shader object.</p>
<p>A program object represents a useable part of render pipeline.</p>
<p><strong><span style="text-decoration: underline;">How To Create Those Objects?</span></strong></p>
<p>A Program object is created with the command<br> GLhandleARB glCreateProgramObjectARB()</p>
<p>A Shader object is created with the commend<br> GLhandleARB glCreateShaderObjectARB(GLenum shaderType)<br> With shaderType equal to GL_VERTEX_SHADER_ARB or GL_FRAGMENT_SHADER_ARB.</p>
<p>So for example: if you want to create a vertex shader object you have to do the following:</p>
<div><div id="highlighter_47104" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">GLenum my_vertex_shader;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">my_vertex_shader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);</code></div></div></td></tr></tbody></table></div></div>
<p><strong><span style="text-decoration: underline;">How To Pass Your Shader Source Code To A Shader Object?</span></strong></p>
<p>This can be done by using</p>
<div><div id="highlighter_352245" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">glShaderSourceARB(GLhangleARB shader, GLuint number_strings, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">GLcharARB** strings, Glint * length);</code></div></div></td></tr></tbody></table></div></div>
<p>With this command you are able to pass more than one string to one shader object.</p>
<ul>
<ul>shader is the target shader object.</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>number_strings is the number of strings you want to pass to the GL.</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>strings is a pointer to a pointer of chars where the source code is saved.</ul>
</ul>
<p>&nbsp;</p>
<ul>length is a pointer to ints where the length of each string is saved. If length is equal to NULL then the strings are assumed to be null terminated.</ul>
<p>Here an example on how to pass a shader source to a vertex shader:</p>
<div><div id="highlighter_706893" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">char</code> <code class="cpp plain">* my_source;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">my_source = GetSource();</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="cpp plain">GLenum my_vertex_shader;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">my_vertex_shader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="cpp plain">glShaderSourceARB(my_vertex_shader, 1, &amp;my_source, NULL);</code></div></div></td></tr></tbody></table></div></div>
<p><strong><span style="text-decoration: underline;">How To Compile A Shader Object?</span></strong></p>
<p>This can simply be done by using</p>
<div><div id="highlighter_29573" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">glCompileShader(GLhandleARB shader);</code></div></div></td></tr></tbody></table></div></div>
<p>shader is our shader object</p>
<p>How to link my shader objects to a program object?</p>
<p>First of all we have to create a program object. Then we attach all shader objects which we want to use to this program object using</p>
<div><div id="highlighter_631220" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">glAttachObjectARB(GLhandleARB program, GLhandleARB shader);</code></div></div></td></tr></tbody></table></div></div>
<p>program is our program object and shader is our shader object</p>
<p>Then we link our program object with</p>
<div><div id="highlighter_687615" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">glLinkProgramARB(GLhandleARB program);</code></div></div></td></tr></tbody></table></div></div>
<p>program is our program object.</p>
<p><strong><span style="text-decoration: underline;">How To Use A Program Object?</span></strong></p>
<p>Program objects can be used with</p>
<div><div id="highlighter_267227" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">glUseProgramObjectARB(GLhandleARB program);</code></div></div></td></tr></tbody></table></div></div>
<p>program is our program object</p>
<p>If program is 0 then standard fixed function OpenGL is used</p>
<p><strong><span style="text-decoration: underline;">Putting All Together</span></strong></p>
<p>Here is a code example for loading, compiling, linking and using shaders:</p>
<div><div id="highlighter_875599" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">char</code> <code class="cpp plain">* my_fragment_shader_source;</code></div><div class="line number2 index1 alt1"><code class="cpp color1 bold">char</code> <code class="cpp plain">* my_vertex_shader_source;</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="cpp comments">// Get Vertex And Fragment Shader Sources</code></div><div class="line number5 index4 alt2"><code class="cpp plain">my_fragment_shader_source = GetFragmentShaderSource();</code></div><div class="line number6 index5 alt1"><code class="cpp plain">my_vertex_shader_source = GetVertexShaderSource();</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="cpp plain">GLenum my_program;</code></div><div class="line number9 index8 alt2"><code class="cpp plain">GLenum my_vertex_shader;</code></div><div class="line number10 index9 alt1"><code class="cpp plain">GLenum my_fragment_shader;</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="cpp comments">// Create Shader And Program Objects</code></div><div class="line number13 index12 alt2"><code class="cpp plain">my_program = glCreateProgramObjectARB();</code></div><div class="line number14 index13 alt1"><code class="cpp plain">my_vertex_shader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);</code></div><div class="line number15 index14 alt2"><code class="cpp plain">my_fragment_shader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);</code></div><div class="line number16 index15 alt1">&nbsp;</div><div class="line number17 index16 alt2"><code class="cpp comments">// Load Shader Sources</code></div><div class="line number18 index17 alt1"><code class="cpp plain">glShaderSourceARB(my_vertex_shader, 1, &amp;my_vertex_shader_source, NULL);</code></div><div class="line number19 index18 alt2"><code class="cpp plain">glShaderSourceARB(my_fragment_shader, 1, &amp;my_fragment_shader_source, NULL);</code></div><div class="line number20 index19 alt1">&nbsp;</div><div class="line number21 index20 alt2"><code class="cpp comments">// Compile The Shaders</code></div><div class="line number22 index21 alt1"><code class="cpp plain">glCompileShaderARB(my_vertex_shader);</code></div><div class="line number23 index22 alt2"><code class="cpp plain">glCompileShaderARB(my_fragment_shader);</code></div><div class="line number24 index23 alt1">&nbsp;</div><div class="line number25 index24 alt2"><code class="cpp comments">// Attach The Shader Objects To The Program Object</code></div><div class="line number26 index25 alt1"><code class="cpp plain">glAttachObjectARB(my_program, my_vertex_shader);</code></div><div class="line number27 index26 alt2"><code class="cpp plain">glAttachObjectARB(my_program, my_fragment_shader);</code></div><div class="line number28 index27 alt1">&nbsp;</div><div class="line number29 index28 alt2"><code class="cpp comments">// Link The Program Object</code></div><div class="line number30 index29 alt1"><code class="cpp plain">glLinkProgramARB(my_program);</code></div><div class="line number31 index30 alt2">&nbsp;</div><div class="line number32 index31 alt1"><code class="cpp comments">// Use The Program Object Instead Of Fixed Function OpenGL</code></div><div class="line number33 index32 alt2"><code class="cpp plain">glUseProgramObjectARB(my_program);</code></div></div></td></tr></tbody></table></div></div>
<p>If all shaders were compiled successfully and the program object was linked successfully all renderings after glUseProgramObjectARB will be done using our shader.</p>
<p><strong><span style="text-decoration: underline;">Some Other Important Functions</span></strong></p>
<p>Of course you also can delete (shader and program) objects with</p>
<div><div id="highlighter_67169" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">glDeleteObjectARB(GLhandleARB object)</code></div></div></td></tr></tbody></table></div></div>
<p>Another VERY important command is</p>
<div><div id="highlighter_22188" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">glGetInfoLogARB(GLhandleARB object, GLsizei maxLenght, GLsizei *length, GLcharARB *infoLog)</code></div></div></td></tr></tbody></table></div></div>
<p>object is a shader or program object.<br> maxLenght is the maximum count of chars which will be written to infoLog.<br> length is the count of chars which were written to InfoLog.<br> infoLog is a pointer to chars where the info log will be saved.</p>
<p>This function gives you information about shader and program objects. For example: if you are calling this function after a failed compiling you will get information why the compiling failed.</p>
<p><strong><span style="text-decoration: underline;">Uniforms</span></strong></p>
<p>Uniforms can be passed to the GL using</p>
<pre>void glUniform{1|2|3|4}{f|i}ARB(GLint location, TYPE val)
void glUniform{1|2|3|4}{f|i}vARB(GLint location, GLuint count, const TYPE * vals)
void glUniformMatrix{2|3|4|}fvARB(GLint location, GLuint count, GLboolean transpose, const GLfloat * vals)
</pre>
<p>location is the location of the uniform.<br> count is the number of values from type TYPE you want to pass.<br> val is a value from TYPE.<br> vals is a pointer to values of TYPE (for matrices only float are available).<br> transpose specifies if the passed matrices should be transposed.</p>
<p>Getting the uniform location can easily be done with</p>
<div><div id="highlighter_717729" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">GLint glGetUniformLocationARB(GLhandleARB program, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">GLcharARB * name)</code></div></div></td></tr></tbody></table></div></div>
<p>program is our program object.<br> name is the name of the uniform which location we want to get.</p>
<p>So heres an example of how to use uniforms:</p>
<div><div id="highlighter_584854" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">glUseProgramObjectARB(my_program);</code></div><div class="line number2 index1 alt1"><code class="cpp color1 bold">int</code> <code class="cpp plain">my_vec3_location = glGetUniformLocationARB(my_program, my_3d_vector);</code></div><div class="line number3 index2 alt2"><code class="cpp plain">glUniform3fARB(my_vec3_location, 1.0f, 4.0f, 3.0f);</code></div></div></td></tr></tbody></table></div></div>
<p>Note that you are not able to pass built-in uniform via glUniform!</p>
<p><strong><span style="text-decoration: underline;">Generic Attributes</span></strong></p>
<p>Generic Attributes are just like Uniforms:</p>
<pre>void glVertexAttrib{1|2|3|4}{s|f|d}ARB(GLuint index, TYPE val)
void glVertexAttrib{1|2|3|4}{s|f|d}vARB(GLuint index, const TYPE * vals)
</pre>
<p>index is the location if the attribute.<br> val is a value from TYPE.<br> vals is a pointer to values of TYPE (for matrices only float are available)</p>
<p>Getting the attribute location can also easily be done with</p>
<div><div id="highlighter_367996" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">GLint glGetAttribLocationARB(GLhandleARB program, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">GLcharARB* name)</code></div></div></td></tr></tbody></table></div></div>
<p>program is our program object.<br> name is the name of the attribute which location we want to get.</p>
<p>An example:</p>
<div><div id="highlighter_482819" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">glUseProgramObjectARB(my_program);</code></div><div class="line number2 index1 alt1"><code class="cpp color1 bold">int</code> <code class="cpp plain">my_vec3_location = glGetAttribLocationARB(my_program, my_3d_vector);</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="cpp plain">glBegin(GL_TRIANGLES);</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">glVertexAttrib3f(my_vec3_location, 4.0f, 2.0f, 7.0f);</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">glVertex3f(1.0f, 1.0f, 1.0f);</code></div><div class="line number7 index6 alt2">&nbsp;</div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">glVertexAttrib3f(my_vec3_location, 2.0f, 9.0f, 2.0f);</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">glVertex3f(-1.0f, 1.0f, 1.0f);</code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">glVertexAttrib3f(my_vec3_location, 1.0f, 0.0f, 5.0f);</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">glVertex3f(1.0f, -1.0f, 1.0f);</code></div><div class="line number13 index12 alt2"><code class="cpp plain">glEnd();</code></div></div></td></tr></tbody></table></div></div>
<p><strong><span style="text-decoration: underline;">Using Textures With GLSL</span></strong></p>
<p>Because many GLSL beginners have problems with texturing I want to say something about this now.</p>
<p>As I said before... textures are available in GLSL via sampler, which have to be uniform. But how do we tell GLSL which texture image should be used for which sampler?</p>
<p>Textures are not directly passed to GLSL, but we pass the texture unit where our texture is bound to OpenGL. This works in the following way:</p>
<ul>
<ul>Get the sampler uniform location.</ul>
</ul>
<p>&nbsp;</p>
<ul>
<ul>Bind the texture to texture unit i.</ul>
</ul>
<p>&nbsp;</p>
<ul>Pass i as an integer by glUniform.</ul>
<p>Here an example:</p>
<div><div id="highlighter_402908" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="http://nehe.gamedev.net/article/glsl_an_introduction/25007/#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">glUseProgramObjectARB(my_program);</code></div><div class="line number2 index1 alt1"><code class="cpp color1 bold">int</code> <code class="cpp plain">my_sampler_uniform_location = glGetUniformLocationARB(my_program, my_color_texture);</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="cpp plain">glActiveTexture(GL_TEXTURE0 + i);</code></div><div class="line number5 index4 alt2"><code class="cpp plain">glBindTexture(GL_TEXTURE_2D, my_texture_object);</code></div><div class="line number6 index5 alt1">&nbsp;</div><div class="line number7 index6 alt2"><code class="cpp plain">glUniform1iARB(my_sampler_uniform_location, i);</code></div></div></td></tr></tbody></table></div></div>
<p>i is the texture unit where I want to bind my texture.</p>
<p>There are many other useful functions for using GLSL. See the extension specification or reference [4] for more information.</p>
<p><strong><span style="text-decoration: underline;">Shader Hardware/Driver Overview</span></strong></p>
<p>Alright, we have heard many about shaders and GLSL. But which hardware is able to run shaders?</p>
<p>GLSL is very similar to DirectX Shader Model 3.0</p>
<p>Right now GLSL is available on the following graphic cards:</p>
<p>ATI Radeon 9500, 9600, 9700 and 9800 using Catalyst 4.5 driver (which is the most bug-free ATI GLSL driver now).</p>
<p>nVidia GeForce FX 5200, 5600, 5700, 5800, 5900, 5950 using forceware 60 series (you can get these drivers at <a href="http://www.3dchipset.com/drivers/beta/nvidia/nt5/6111.php" target="_blank">http://www.3dchipset.com/drivers/beta/nvidia/nt5/6111.php</a> )</p>
<p>Because of the fact that these cards only support Shader Model 2.0 some features of GLSL are not available, like loops, vertex shader sampler </p>
<p>I don't think anything older than these cards will support GLSL fragment shader. However I think there might be vertex shader emulation in driver software for these cards.</p>
<p><strong><span style="text-decoration: underline;">GLSL Shader Development Tools</span></strong></p>
<p>There are also some nice shader development tools for GLSL:</p>
<p>Typhoon Labs has a really nice shader development tool called Shader Designer. You can get it at <a href="http://www.typhoonlabs.com/" target="_blank">http://www.typhoonlabs.com</a></p>
<p>ATI and 3Dlabs are also working together on a GLSL version of RenderMonkey. This tool is not available yet but should come out very soon!</p>
<p><strong><span style="text-decoration: underline;">GLSL References</span></strong></p>
<p>Finally, I would like to list some nice GLSL references:</p>
<p><a href="http://www.clockworkcoders.com/oglsl" target="_blank">http://www.clockworkcoders.com/oglsl</a><br> Some really nice tutorials!</p>
<p><a href="http://www.3dlabs.com/support/developer/ogl2/index.htm" target="_blank">http://www.3dlabs.com/support/developer/ogl2/index.htm</a><br> 3DLabs GLSL site</p>
<p><a href="http://www.ati.com/developer/sdk/RadeonSDK/Html/Samples/OpenGL/GLSLSimpleShader.html" target="_blank">http://www.ati.com/developer/sdk/RadeonSDK/Html/Samples/OpenGL/GLSLSimpleShader.html</a><br> ATI GLSL examples</p>
<p><a href="http://developer.nvidia.com/object/sdk_home.html#NV40_Video_Clips" target="_blank">http://developer.nvidia.com/object/sdk_home.html#NV40_Video_Clips</a><br> NV SDK 7.0 with some GLSL examples</p>
<p><a href="http://esprit.campus.luth.se/~humus" target="_blank">http://esprit.campus.luth.se/~humus</a><br> Humus site with also some nice GLSL examples</p>
<p>Thanks for reading!<br> Questions and Feedback is welcome! :-)<br> <a href="mailto:corrail@gmx.at"><strong>Florian Rudolf</strong></a><br> ICQ# 59184081</p>
<p>"If you want to contact my please make sure that it doesn't look like spam! I get a lot of spam mail/ICQ requests... Everything suspicious will be deleted"</p>
<p><strong><span style="text-decoration: underline;">References:</span></strong></p>
<p>[1] OpenGL Shading Language Master Class Notes, 3DLabs, March/April 2004<br> <a href="http://www.3dlabs.com/support/developer/ogl2/presentations/GLSLMasterClass2004.pdf">http://www.3dlabs.com/support/developer/ogl2/presentations/GLSLMasterClass2004.pdf</a><br> [2] The OpenGL Shading Language Specification Version 1.051, 3DLabs, February 2003<br> <a href="http://www.3dlabs.com/support/developer/ogl2/downloads/ShaderSpecV1.051.pdf">http://www.3dlabs.com/support/developer/ogl2/downloads/ShaderSpecV1.051.pdf</a><br> [3] The OpenGL extension registry<br> <a href="http://oss.sgi.com/projects/ogl-sample/registry/">http://oss.sgi.com/projects/ogl-sample/registry/</a><br> [4] OpenGL shading language The orange book, Randi J. Rost, ISBN 0-321-19789-5<br> <a href="http://www.3dshaders.com/">http://www.3dshaders.com/</a></p>
<p>&nbsp;</p>


</div>




            <div style="width:728px;padding:0px;margin:auto; margin-top: 10px;">
            
                <!-- Leaderboard_NeHe -->
                <div id="div-gpt-ad-1327940144417-0" style="width:728px; height:90px;">
                <script type="text/javascript">
                googletag.cmd.push(function() { googletag.display('div-gpt-ad-1327940144417-0'); });
                </script>
                </div>
                                       
            </div>   
        </td>
        <td class="col2">
            



            
        </td>
    </tr></tbody></table>
    <div id="footer">
        <p>
            
    
    © 1997-2014 Gamedev . All rights reserved.<br>

			NeHe™ and NeHe Productions™ are trademarks of GameDev.net, LLC<br>
			OpenGL® is a registered trademark of Silicon Graphics Inc.<br>
		</p>        
		<br>
    </div>

    
    
	    <script type="text/javascript" src="./NeHe Productions_ GLSL_ An Introduction_files/shCore.js.download"></script>
        <script type="text/javascript" src="./NeHe Productions_ GLSL_ An Introduction_files/shBrushCpp.js.download"></script>
	    <script type="text/javascript" src="./NeHe Productions_ GLSL_ An Introduction_files/shBrushJScript.js.download"></script>
	    <script type="text/javascript">SyntaxHighlighter.all();</script>
    

    <!-- Place this render call where appropriate -->
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>

    
<!-- GoogleAnalytics code -->
<script src="./NeHe Productions_ GLSL_ An Introduction_files/urchin.js.download" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-279474-2"; // Gamedev
urchinTracker();
</script> 
  

<iframe name="oauth2relay1187346605" id="oauth2relay1187346605" src="./NeHe Productions_ GLSL_ An Introduction_files/postmessageRelay.html" tabindex="-1" aria-hidden="true" style="width: 1px; height: 1px; position: absolute; top: -100px;"></iframe></body></html>