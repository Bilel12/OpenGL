
<!-- saved from url=(0040)http://www.cburch.com/cs/490/sched/feb8/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>CSci 490: OpenGL Sphere</title>
</head>

<body bgcolor="FFFFFF" link="AA0000" alink="FF3300">

<h1>OpenGL Sphere</h1>

<p>I have two screen shots of the following program, depending on
how line 58 is written.
</p><center><table><tbody><tr>
	<td align="center"><img src="./CSci 490_ OpenGL Sphere_files/sph-flat.png" width="200"></td>
    <td align="center"><img src="./CSci 490_ OpenGL Sphere_files/sph-smooth.png" width="200"></td>
</tr><tr>
	<td align="center"><tt>glShadeModel(GL_FLAT);</tt></td>
	<td align="center"><tt>glShadeModel(GL_SMOOTH);</tt></td>
</tr></tbody></table></center><p></p>

<pre>  1  #include <stdlib.h>
  2  #include <math.h>
  3  #include <gl glut.h="">
    
  4  double user_theta  = 0;
  5  double user_height = 0;
    
  6  void drawSphere(double r, int lats, int longs) {
  7      int i, j;
  8      for(i = 0; i &lt;= lats; i++) {
  9          double lat0 = M_PI * (-0.5 + (double) (i - 1) / lats);
 10          double z0  = sin(lat0);
 11          double zr0 =  cos(lat0);
    
 12          double lat1 = M_PI * (-0.5 + (double) i / lats);
 13          double z1 = sin(lat1);
 14          double zr1 = cos(lat1);
    
 15          glBegin(GL_QUAD_STRIP);
 16          for(j = 0; j &lt;= longs; j++) {
 17              double lng = 2 * M_PI * (double) (j - 1) / longs;
 18              double x = cos(lng);
 19              double y = sin(lng);
    
 20              glNormal3f(x * zr0, y * zr0, z0);
 21              glVertex3f(x * zr0, y * zr0, z0);
 22              glNormal3f(x * zr1, y * zr1, z1);
 23              glVertex3f(x * zr1, y * zr1, z1);
 24          }
 25          glEnd();
 26      }
 27  }
    
 28  void computeLocation() {
 29      double x = 2 * cos(user_theta);     // my x-, y-, and z-coordinates
 30      double y = 2 * sin(user_theta);
 31      double z = user_height;
 32      double d = sqrt(x * x + y * y + z * z); // distance to origin
    
 33      glMatrixMode(GL_PROJECTION);        // Set projection parameters.
 34      glLoadIdentity();
 35      glFrustum(-d * 0.5, d * 0.5, -d * 0.5, d * 0.5, d - 1.1, d + 1.1);
 36      gluLookAt(x, y, z,  0, 0, 0,  0, 0, 1);
 37  }
    
 38  // Initializes information for drawing within OpenGL.
 39  void init() {
 40      GLfloat sun_direction[] = { 0.0, 2.0, -1.0, 1.0 };
 41      GLfloat sun_intensity[] = { 0.7, 0.7, 0.7, 1.0 };
 42      GLfloat ambient_intensity[] = { 0.3, 0.3, 0.3, 1.0 };
    
 43      glClearColor(1.0, 1.0, 1.0, 0.0);   // Set window color to white.
 44      computeLocation();
    
 45      glEnable(GL_DEPTH_TEST);            // Draw only closest surfaces
    
 46      glEnable(GL_LIGHTING);              // Set up ambient light.
 47      glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambient_intensity);
    
 48      glEnable(GL_LIGHT0);                // Set up sunlight.
 49      glLightfv(GL_LIGHT0, GL_POSITION, sun_direction);
 50      glLightfv(GL_LIGHT0, GL_DIFFUSE, sun_intensity);
    
 51      glEnable(GL_COLOR_MATERIAL);        // Configure glColor().
 52      glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
 53  }
    
 54  // Draws the current image.
 55  void draw() {
 56      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear window.
 57      glColor3f(1.0, 1.0, 1.0);
 58      glShadeModel(GL_SMOOTH);
 59      drawSphere(1.0, 10, 10); // glutSolidSphere(1.0, 10, 10);
 60      glutSwapBuffers();
 61  }
    
 62  // Arranges that the window will be redrawn roughly every 40 ms.
 63  void idle() {
 64      static int lastTime = 0;                // time of last redraw
 65      int time = glutGet(GLUT_ELAPSED_TIME);  // current time
    
 66      if(lastTime == 0 || time &gt;= lastTime + 40) {
 67          lastTime = time;
 68          glutPostRedisplay();
 69      }
 70  }
    
 71  // When window becomes visible, we want the window to
 72  // continuously repaint itself.
 73  void visible(int vis) {
 74      glutIdleFunc(vis == GLUT_VISIBLE ? idle : NULL);
 75  }
    
 76  // Called when a "special" key is pressed
 77  void special(int k, int x, int y) {
 78      switch(k) {
 79      case GLUT_KEY_UP:    user_height += 0.1; break;
 80      case GLUT_KEY_DOWN:  user_height -= 0.1; break;
 81      case GLUT_KEY_LEFT:  user_theta  += 0.1; break;
 82      case GLUT_KEY_RIGHT: user_theta  -= 0.1; break;
 83      }
 84      computeLocation();
 85      glutPostRedisplay();
 86  }
    
 87  int main(int argc, char **argv) {
 88      glutInit(&amp;argc, argv);
 89      glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGB);
 90      glutInitWindowPosition(50, 100);    // Set up display window.
 91      glutInitWindowSize(300, 300);
 92      glutCreateWindow("Sphere");
    
 93      init();
 94      glutDisplayFunc(draw);
 95      glutVisibilityFunc(visible);
 96      glutSpecialFunc(special);
 97      glutMainLoop();
 98      return 0;
 99  }
</gl></math.h></stdlib.h></pre>



</body></html>