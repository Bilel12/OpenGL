 function SliderRangeDlg() {  var html= "<div id='rangedlg' style='position:absolute; left:100px; top:50px; visibility:hidden; background:#ece9e8; width: 300px; height:185px; border:2px outset gray; z-index:1000;'>" +"<div id='dlgHead' style='background:#7b97e0; color:white; font-family:sans-serif; font-size:14px ; height:21px; padding:4px 0 0 20px'></div>" +"<table style='margin-top:20px;margin-bottom:15px'  border=0 align=center cellspacing=4>" +"<tr><td>Upper limit</td><td><INPUT id='upper'></td></tr>" +"<tr><td>Lower limit</td><td><INPUT id='lower' ></td></tr>" +"<tr style='color:red; text-align:center;height:24px'><td id='errmsg' colspan='2'></td></tr>" +"</table>" +"<INPUT   style='margin-left:90px; margin-right:20px' id='ok' TYPE='button' value='OK' onclick='dlgok()' >" +"<INPUT  TYPE='button'  value='Cancel' onclick='closeDlg()'>" +"</div>"; var bod=document.getElementsByTagName('body')[0]; bod.innerHTML +=html; this.show=function(slider) { rangeSlider=slider; document.getElementById('rangedlg').style.visibility="visible";  document.getElementById('dlgHead').innerHTML="Set range for slider "+slider.labl.text; document.getElementById('upper').value=slider.high; document.getElementById('lower').value=slider.low; }; }; function closeDlg() { document.getElementById('rangedlg').style.visibility="hidden"; }; function dlgok() { var upperLim=document.getElementById('upper').value; var lowerLim=document.getElementById('lower').value; document.getElementById('errmsg').innerHTML=""; if(!goodInput(upperLim)) return; if(!goodInput(lowerLim)) return; var upperNum=new Number(upperLim); var lowerNum=new Number(lowerLim); if(upperNum < lowerNum) { document.getElementById('errmsg').innerHTML="Lower limit must be less than upper"; return; } if(upperNum < lowerNum) { document.getElementById('errmsg').innerHTML="Lower limit must be less than upper"; return; } if( !inRange(upperNum) || !inRange(lowerNum) ) { document.getElementById('errmsg').innerHTML="Limits must be between +99 and -99"; return; }  rangeSlider.setHigh(upperNum); rangeSlider.setLow(lowerNum);  rangeSlider.setValue(rangeSlider.getValue()); update(); closeDlg(); }; function goodInput(val) { var num=new Number(val); if(val.trim().length==0 || isNaN(val) ) { document.getElementById('errmsg').innerHTML="Both limits must be valid numbers"; return false; } else return true; }; function inRange(v) { return (v<=99 && v>-99); }; function Axes(wid, ht)  { this.wid=wid; this.ht=ht; this.xMin; this.xMax; this.yMin; this.yMax; this.wid; this.ht; this.gridColor=0xbbbbaa; this.gridAlpha=1; this.axisColor=0x56789a; this.arrowColor=0x888888; this.labelColor=0x5555aa; this.labels=new Sprite();  addChild(this.labels); this.clear=function() { this.labels.removeChild("all"); }; this.draw=function(xMin, xMax, yMin, yMax, gridVisible) { this.xMin=xMin; this.xMax=xMax; this.yMin=yMin; this.yMax=yMax;  this.clear(); if(gridVisible) { this.drawXGrid(); this.drawYGrid(); } this.drawAxes(); }; this.drawXGrid=function() { var xPeriod=this.gridDelta(this.xMax , this.xMin); var firstGridLine=(Math.round(this.xMin/xPeriod)+1)*xPeriod; var vPos=this.ht-20; var labelVal; var CENTER=3;  with(this) { if(sign(yMin) !=sign(yMax)) vPos=ytoPix(0)+graphTop+3; for(var i=firstGridLine; i<xMax; i+=xPeriod) { i=roundtoN(i,3);  with(graphics) { lineStyle(1,gridColor, gridAlpha); moveTo(graphLeft+xtoPix(i), graphTop); lineTo(graphLeft+xtoPix(i), graphTop+graphHeight); } labelVal=roundtoN(i,2); if(labelVal !=0) { makeLabel(xtoPix(i)+graphLeft , vPos, labelVal, CENTER); } } } }; this.drawYGrid=function() { with (this) { var LEFT=1; var RIGHT=2; var CENTER=3; var yPeriod=this.gridDelta(yMax , yMin); var firstGridLine=(Math.round(yMin/yPeriod)+1)*yPeriod; var hPos, align; var labelVal;  if(xtoPix(0) <0)  { hPos=3; align=LEFT; } else if (xtoPix(0)> wid)  { hPos=wid; align=RIGHT; } else if(xtoPix(0)> wid-20)  { hPos=xtoPix(0)-3; align=RIGHT; } else if(xtoPix(0)==0)  { hPos=3 ; align=LEFT; } else  { hPos=xtoPix(0)+graphLeft+4; align=LEFT; } for(var i=firstGridLine; i<yMax; i+=yPeriod) { i=roundtoN(i,3);  with(graphics) { lineStyle(1,gridColor, gridAlpha); moveTo(graphLeft, ytoPix(i)+graphTop ); lineTo(graphLeft+graphWidth, ytoPix(i)+graphTop); } labelVal=roundtoN(i,2); if(labelVal !=0) { makeLabel(hPos, ytoPix(i)+graphTop-9, labelVal, align); } } }  }; this.makeLabel=function(xLoc, yLoc, txt, align) { var LEFT=1; var RIGHT=2; var CENTER=3; var label=new TextObj(0,0,txt,0x666666); with(label) { var width=getWidth(); switch(align) { case LEFT: x=xLoc; break; case RIGHT: x=xLoc - width; break; case CENTER: x=xLoc - width/2; break; } y=yLoc; } this.labels.addChild(label); return label; }; this.gridDelta=function(vMin, vMax)   { var decade=0; var period;  var range=Math.abs(vMax-vMin);  while(range>10) { range /=10; decade++; } while(range<1 ) { range *=10; decade--; } period=Math.ceil(range)/10; return period*Math.pow(10,decade); }; this.drawAxes=function() { with(this) { var y0=ytoPix(0)+graphTop; var x0=Math.round( xtoPix(0) ) + graphLeft; if(x0==wid) x0=wid-2; if(x0==0) x0=2; with(graphics) {  lineStyle(1.4, axisColor); moveTo(graphLeft, y0); lineTo(graphLeft+graphWidth,y0);  lineStyle(1.4, axisColor); moveTo(x0,graphTop); lineTo(x0,graphTop+graphHeight); } }  }; this.xtoPix=function(mathx) { with(this) { return ( wid*(mathx - xMin)/(xMax - xMin) ); } }; this.ytoPix=function(mathy) { with(this) { return ( ht*(yMax - mathy)/(yMax - yMin) ); } }; this.sign=function(x) { var POS=1; var NEG=-1; if(x<0) return NEG; else return POS; }; };    function FunctionField (labl, xLoc, yLoc, color, fillColor, readoutY, callback) { this.type="FunctionField"; this.color; this.fillColor; this.lab; this.relop; this.fn; this.compiledFn=null; this.display; this.inpFmt; this.labl; this.csrDot; this.x=0; this.y=0; this.color=color; this.fillColor=fillColor; this.labl=labl; this.defaultFillColor=fillColor; this.lab=new TextObj(xLoc, yLoc, labl, color, false, false, 14 );  this.relop=new ComboBox(callback);  with(this.relop) { x=xLoc+29; y=yLoc; height=21; width=44; addItem({label:"=" , data:"eq"} );  addItem({label:"<" , data:"lt"} );  addItem({label:"<=" , data:"le"} );  addItem({label:">" , data:"gt"} );  addItem({label:">=" , data:"ge"} );  selectedIndex=0;  update(); }; this.fn=new TextField(); with (this.fn) { x=xLoc+75; y=yLoc+1; width=310; textColor=color; }; this.display=new Checkbox(this.fn.x + this.fn.width+6, yLoc+3, "show", true, true, callback);  addChild(this.lab); addChild(this.display); addChild(this.relop); this.update=function() { this.fn.update(); this.relop.update(); this.display.update(); }; this.reset=function() {}; this.paint=function() {}; this.setMono=function(mono) { if(mono) this.fillColor=0x000000; else this.fillColor=this.defaultFillColor; }; this.setCsrDot=function(xLoc, yLoc, vis) { with(csrDot) { x=xLoc; y=yLoc; visible=vis; } }; };  function GraphCursor(hgt, wid, xMin, xMax, yMin, yMax,f1, f2, f3, evalFn)  { this.type="GraphCursor"; this.x=0; this.y=0; this.xMin=xMin; this.xMax=xMax; this.yMin=yMin; this.yMax=yMax; this.f1=f1; this.f2=f2; this.f3=f3; this.evalFn=evalFn; this.color=0x0048d8; this.hairlineX;  this.visible=true; this.built=false; this.xMin, this.xMax, this.yMin, this.yMax; this.f1; this.f2; this.f3; this.hintPt=new GeomPoint(0,60); this.hint=new Hint(this.hintPt, Hint.ABOVERT, "Drag cursor line"); this.xLabel; this.xValueBox; this.firstTime=true;  this.draggingLine=false; this.fingerOffset=0;  this.xLabel=new TextObj(40,26, "x =", 0x666666, true, true, 14); this.xValueBox=new TextField(); with(this.xValueBox) { x=68; y=24; width=50; height=17; border=true; borderColor=0x888888; background=true; backgroundColor=0xffffff; textColor=0x000000; };   this.can=document.createElement('canvas'); with( this.can) { with(style) { position="absolute"; top= (graphTop*bScale)+"px"; left=(graphLeft*bScale)+"px"; } width=graphWidth*bScale; height=graphHeight*bScale; }  document.body.appendChild(this.can); this.context=this.can.getContext('2d'); this.context.scale(bScale, bScale); this.update=function() { this.paint(); }; this.reset=function() {}; this.paint=function() { if(!this.built) this.build();  this.xValueBox.visible=this.visible; this.xLabel.visible=this.visible; this.context.clearRect(0,0,graphWidth, graphHeight); if(this.visible) with(this) { with(context)  { beginPath(); moveTo(this.hairlineX, 0); lineTo(this.hairlineX, graphHeight); strokeStyle= "red"; stroke(); } setReadout(f1, 45, 0x0000ff);  setReadout(f2, 63, 0x000000); setReadout(f3, 81, 0xff0000); } }; this.build=function()    {  addChild(this.xLabel); addChild(this.xValueBox); this.can.onmousemove=this.mouseMove; this.can.onmousedown=this.mouseDown; this.can.onmouseup=this.mouseUp; this.can.ontouchstart=this.touchStart; this.can.ontouchmove=this.touchMove; this.can.ontouchend=this.touchEnd; this.built=true; }; this.touchStart=function(e) { if (!e) var e=event; e.preventDefault(); if(graphCsr.visible) { var x= e.pageX/bScale - graphLeft; graphCsr.draggingLine=true; graphCsr.fingerOffset=x - graphCsr.hairlineX;  } }; this.touchMove=function(e) { if(graphCsr.visible && graphCsr.draggingLine) { if (!e) var e=event; e.preventDefault(); var x= e.pageX/bScale - graphLeft; var newHairlineX= x -graphCsr.fingerOffset; graphCsr.hairlineX=Math.round(newHairlineX)+0.5;  graphCsr.setReadoutsFromHairline(); graphCsr.paint(); } }; this.touchEnd=function(e) { graphCsr.draggingLine=false; graphCsr.fingerOffset=0 }; this.mouseMove=function(e) { if(graphCsr.visible) { if (!e) var e=event; var x= e.pageX/bScale - graphLeft; if(graphCsr.draggingLine) { graphCsr.hairlineX=Math.round(x)+0.5;  graphCsr.setReadoutsFromHairline(); graphCsr.paint(); } var inRange=(Math.abs(x-graphCsr.hairlineX)<3); graphCsr.can.style.cursor=inRange? "pointer" : "auto"; } }; this.mouseDown=function(e) { if(graphCsr.visible) { if (!e) var e=event; var x= e.pageX/bScale - graphLeft; graphCsr.hint.visible=false; var inRange=(Math.abs(x-graphCsr.hairlineX)<3); if(inRange) { graphCsr.draggingLine=true; } } }; this.mouseUp=function(e) { graphCsr.draggingLine=false; }; this.setReadoutsFromHairline=function() { var mathX=this.xMin.val + ((this.hairlineX/graphWidth)*(this.xMax.val - this.xMin.val)); this.xValueBox.setValue(roundtoN(mathX, 4)); }; this.getXVal=function() { return this.xValueBox.getValue(); }; this.setReadout=function(func, yLoc, color)  { if(func.compiledFn !=null && func.display.selected) { var xVal=this.xValueBox.getValue(); var yVal=this.evalFn(func, xVal); var readoutText; if( isNaN(yVal) ) { readoutText=func.labl + " = undefined"; } else { yVal=roundtoN(yVal, 4); readoutText=func.labl + " = "+yVal; }  this.context.fillStyle=toStr(color, 0.5); this.context.font="italic bold 12px sans-serif"; this.context.fillText(readoutText, 3, yLoc);  var dotX=this.xtoPix(xVal); var dotY=this.ytoPix(yVal); with(this.context) { beginPath(); arc(dotX, dotY, 2, 0 ,Math.PI*2, true);  fill(); } } }; this.setCsrXval=function(val)    { if(val==null) this.xValueBox.setValue(0); else this.xValueBox.setValue( roundtoN(val, 4) ); }; this.setFromInputBox=function()   { var input=this.xValueBox.getValue(); var range=this.xMax.val-this.xMin.val; var csrFrac=(input-this.xMin.val)/range;  this.hairlineX=graphWidth*csrFrac; }; this.xtoPix=function(mathx) { var res=graphWidth*(mathx - this.xMin.val)/(this.xMax.val - this.xMin.val); return res; }; this.ytoPix=function(mathy) { var res=graphHeight*(this.yMax.val - mathy)/(this.yMax.val - this.yMin.val) ; return res; }; };   var p_singleParamFnNames=["sin","cos","tan","log","ln","sqrt", "exp", "abs", "acos","asin", "atan" ,"ceil", "floor", "round","sec","csc","cot"]; var p_twoParamFnNames=["max","min","plus","minus","mul","div","pow"]; var p_iserror=0; var p_errorMes=""; var p_tokenvalue; var p_tokenType; var p_tokenLength; var p_digits="0123456789."; var p_letters="abcdefghijklmnopqrstuwvxzy"; var p_operators="^*+-/(),"; var p_varNames; function doCompile(inputstring, varArray) { var stepString; var conString; var fstack=[];  p_varNames=[]; for(var i=0 ; i<varArray.length ; i++) { p_varNames[i]=varArray[i].toLowerCase(); } p_iserror=0; p_errorMes=""; stepString=whiteSpaces(inputstring);  if(stepString=="") return errorObject("", 0);  checkLegal(stepString);  if(p_iserror==1) return errorObject(p_errorMes, 1); checkPars(stepString); if(p_iserror==1) return errorObject(p_errorMes, 1);  checkToks(stepString);  if(p_iserror==1) return errorObject(p_errorMes, 1); conString=conOper(conOper(conOper(conOper(conUnary(conCaret(stepString)),"/"),"*"),"-"),"+"); if(p_iserror==1) return errorObject(p_errorMes, 1); fstack=makeStack(conString); if(p_iserror==1) return errorObject(p_errorMes, 1);  var coCompObj=new CompiledObject(); with( coCompObj) { polishArray=fstack; p_errorMes=""; errorStatus=0; } return coCompObj; }; function isTokenF1(chars) { for(var i=0; i< p_singleParamFnNames.length; i++) { if(chars==p_singleParamFnNames[i]) return true; } return false; }; function isTokenF2(chars) { for(var i=0; i< p_twoParamFnNames.length; i++) { if(chars==p_twoParamFnNames[i]) return true; } return false; }; function isVariable(chars) { for(var i=0; i< p_varNames.length; i++) { if(chars==p_varNames[i]) return true; } return false; }; function isLetter(char) { return p_letters.indexOf(char) >=0 ; }; function isOperator(char) { return p_operators.indexOf(char) >=0 ; }; function isNumber(char) { return p_digits.indexOf(char) >=0 ; }; function setToken(curtype,curvalue,curlength) { p_tokenType=curtype; p_tokenvalue=curvalue; p_tokenLength=curlength; }; function nextToken(inputstring,pos) { var char, t, inilen, cpos, cstring; cstring=inputstring; cpos=pos; inilen=inputstring.length; if(cpos >=inilen || cpos<0) return false; char=cstring.charAt(cpos); if(isLetter(char)) { t=char; do { cpos+=1; if(cpos >=inilen) break; char=cstring.charAt(cpos); if(!isLetter(char)) break; t+=char; } while(1); if(isTokenF1(t)) { setToken("f1", t, t.length); return true; } else if(isTokenF2(t)) { setToken("f2" ,t, t.length); return true; } else { setToken("variable", t ,t.length); return true; } } if(isNumber(char)) { t=char; do { cpos+=1; if(cpos >=inilen) break; char=cstring.charAt(cpos); if(!isNumber(char)) break; t+=char; } while(1); setToken("num",t,t.length); return true; } if(isOperator(char)) { setToken("oper",char,1); return true; } return false; }; function checkToks(inputstring) { var pstring, pinilen, ppos, fpos, bpos, fchar, bchar, counter, matchpar, iscomma, comcounter; pstring=inputstring; ppos=0; counter=0; comcounter=0; pinilen=pstring.length; if(pstring.indexOf("---") >=0) { setError("Too many minuses."); return; } while(ppos < pinilen && counter<pinilen*2) { if(nextToken(pstring , ppos)) { fpos=ppos+p_tokenLength; fchar=pstring.charAt(fpos); bpos=(ppos-1); bchar=pstring.charAt(bpos); if(p_tokenType=="f1") { if(!(fchar=="(")) { setError("'(' expected at position " + fpos +"."); return; } if(ppos > 0 && !(isOperator(bchar))) { setError("Operator expected at position " + bpos +"."); return; } if(ppos > 0 && bchar==")") { setError("Operator expected at position " + bpos +"."); return; } } if(p_tokenType=="f2") { if(!(p_tokenvalue=="max") && !(p_tokenvalue=="min")&& !(p_tokenvalue=="pow")) { setError("Unknown functions at position " + fpos +"."); return; } if(!(fchar=="(")) { setError("'(' expected at position " + fpos +"."); return; } else { matchpar=1; iscomma=0; comcounter=0; while(matchpar>0 && comcounter<pinilen) { comcounter++; if(pstring.charAt(fpos+comcounter)=="("){matchpar+=1;} if(pstring.charAt(fpos+comcounter)==")"){matchpar+=-1;} if(pstring.charAt(fpos+comcounter)==","){iscomma+=1;} } if(iscomma==0) { setError("Two arguments expected for function at position " + ppos +"."); return; } } if(ppos > 0 && !(isOperator(bchar))) { setError("Operator expected at position " + bpos +"."); return; } if(ppos > 0 && bchar==")") { setError("Operator expected at position " + bpos +"."); return; } } if(p_tokenType=="variable")  { if(!(isVariable(p_tokenvalue) || p_tokenvalue=="pi" || p_tokenvalue=="e")) { setError("Unknown entries at position " + ppos +"."); return; } if(ppos > 0 && !(isOperator(bchar))) { setError("Operator expected at position " + bpos +".");return; } if(ppos > 0 && bchar==")") { setError("Operator expected at position " + bpos +".");return; } if(fpos < pinilen && !(isOperator(fchar))) { setError("Operator expected at position " + fpos +"."); return; } if(fpos < pinilen && fchar=="(") { setError("Operator expected at position " + fpos +"."); return; } } if(p_tokenType=="num")  { if(ppos > 0 && !(isOperator(bchar))) { setError("Operator expected at position " + bpos +".");return; } if(ppos > 0 && bchar==")") { setError("Operator expected at position " + bpos +"."); return; } if(fpos < pinilen && !(isOperator(fchar))) { setError("Operator expected at position " + fpos +"."); return; } if(fpos < pinilen && fchar=="(") { setError("Operator expected at position " + fpos +".");return; } } if(p_tokenvalue=="(") { if(fpos < pinilen && ("^*,)+/").indexOf(fchar)>=0) { setError("Entries expected at position " + fpos +"."); return; } } if(p_tokenvalue==")") { if(fpos < pinilen && ("^*+-,/)").indexOf(fchar)==-1) { setError("Entries expected at position " + fpos +"."); return; } if(bpos >=0 && ("^*+-,/(").indexOf(bchar)>=0) { setError("Entries expected at position" + fpos +"."); return; } } if(p_tokenvalue==",") { if(ppos==0 || ppos==pinilen-1) { setError("Stray comma at position " + ppos +"."); return; } if(fpos < pinilen && ("^*+,/)").indexOf(fchar)>=0) { setError("Entries expected at position " + fpos +"."); return; } if(bpos >=0 && ("^*+-,/(").indexOf(bchar)>=0) { setError("Entries expected at position " + fpos +"."); return; } } if(("^/*-+").indexOf(p_tokenvalue)>=0) { if(("+*^/),").indexOf(fchar)>=0) { setError("Entries expected at position " + fpos +"."); return; } if(("+*^/(,").indexOf(bchar)>=0 && !(p_tokenvalue=="-")) { setError("Entries expected at position " + fpos +"."); return; } } } else { setError("Unknown characters at position ." + ppos);} ppos+=p_tokenLength; counter+=1; } }; function conOper(inputstring, char)  { var transtring, inilen, mco, curpos, leftoper, rightoper,leftmove,rightmove; inilen=inputstring.length; transtring=inputstring; if(transtring.indexOf(char)==-1)  return transtring; if(transtring.indexOf(char)==0 && !(char=="-"))  { setError("Error at the first " + char); return ""; } if(transtring.charAt(transtring.length-1)==char)  { setError("Error at the last " + char + "."); return ""; } mco=0; while(transtring.indexOf(char)>0 && mco<inilen*6) { mco++; curpos=transtring.indexOf(char); leftmove=goLeft(transtring,curpos); if(p_iserror==1) { setError("Error at  " + char + "  number " + mco + "."); return ""; } leftoper=transtring.substring(leftmove+1,curpos); rightmove=goRight(transtring,curpos); if(p_iserror==1) { setError("Error at  " + char + "  number " + mco + "."); return ""; } rightoper=transtring.substring(curpos+1, rightmove); if(char=="*")  { transtring=transtring.substring(0,leftmove+1) + "mul("+ leftoper+ "," + rightoper + ")" + transtring.substring(rightmove,transtring.length+1); } if(char=="/")  { transtring=transtring.substring(0,leftmove+1) + "div("+ leftoper+ "," + rightoper + ")" + transtring.substring(rightmove,transtring.length+1); } if(char=="-")  { transtring=transtring.substring(0,leftmove+1) + "minus("+ leftoper + "," + rightoper + ")" + transtring.substring(rightmove,transtring.length+1); } if(char=="+")  { transtring=transtring.substring(0,leftmove+1) + "plus("+ leftoper + "," + rightoper + ")" + transtring.substring(rightmove,transtring.length+1); } }  return transtring; }; function conUnary(inputstring)  { var transtring, inilen, mco, curpos, j; inilen=inputstring.length; transtring=inputstring; if(transtring.indexOf("-")==-1)  { return transtring; } if(transtring.charAt(transtring.length-1)=="-")  { setError("Error at the last minus."); return ""; } for(var i=0; i<transtring.length; i++) { if(transtring.charAt(i)=="-" && unaryId(transtring.charAt(i-1))) { j=goRight(transtring, i); if(p_iserror==1) { setError("Error at position " + i); return ""; } transtring=transtring.substring(0,i) + "minus(0,"+transtring.substring(i+1,j) + ")" + transtring.substring(j,transtring.length); } } return transtring; }; function unaryId(char) { return ("+-,(/*^".indexOf(char)>-1) }; function goRight(inputstring, pos) { var rightchar, rightcounter, matchpar; rightchar=inputstring.charAt(pos+1); rightcounter=pos+1; if(rightchar=="-") { rightcounter++; if(rightcounter>=inputstring.length) { p_iserror=1; return rightcounter; } else { rightchar=inputstring.charAt(rightcounter); } } if(p_digits.indexOf(rightchar)>-1) { while(p_digits.indexOf(inputstring.charAt(rightcounter))>-1 && rightcounter<inputstring.length) rightcounter++; } else if(p_letters.indexOf(rightchar)>-1) { while(p_letters.indexOf(inputstring.charAt(rightcounter))>-1 && rightcounter<inputstring.length) rightcounter++; if(inputstring.charAt(rightcounter)=="(") { matchpar=1; while(matchpar>0 && rightcounter<inputstring.length) { rightcounter+=1; if(inputstring.charAt(rightcounter)=="(") matchpar++; if(inputstring.charAt(rightcounter)==")"){matchpar--;} } } if(matchpar>0) { p_iserror=1; return rightcounter; } } else if(rightchar=="(") { matchpar=1; while(matchpar>0 && rightcounter<inputstring.length) { rightcounter++; if(inputstring.charAt(rightcounter)=="(") matchpar++; if(inputstring.charAt(rightcounter)==")") matchpar--; } rightcounter++; if(matchpar>0) { p_iserror=1; return rightcounter;} } else { p_iserror=1; return rightcounter; } return rightcounter; }; function goLeft(inputstring, pos) { var leftchar, leftcounter, matchpar; leftchar=inputstring.charAt(pos-1); leftcounter=pos-1; if(p_digits.indexOf(leftchar)>-1) while(p_digits.indexOf(inputstring.charAt(leftcounter))>-1 && leftcounter>=0) leftcounter--; else if(p_letters.indexOf(leftchar)>-1) while(p_letters.indexOf(inputstring.charAt(leftcounter))>-1 && leftcounter>=0) leftcounter--; else if(leftchar==")") { matchpar=1; if(leftcounter==0) { p_iserror=1; return leftcounter; } while(matchpar>0 && leftcounter>0) { leftcounter+=-1; if(inputstring.charAt(leftcounter)==")") matchpar++; if(inputstring.charAt(leftcounter)=="("){matchpar--;} } leftcounter+=-1; if(matchpar>0) { p_iserror=1; return leftcounter; } if(leftcounter>=0 && p_digits.indexOf(inputstring.charAt(leftcounter))>-1) { p_iserror=1; return leftcounter; } if(leftcounter==0 && !(inputstring.charAt(leftcounter)=="-")&& !(inputstring.charAt(leftcounter)=="(")) { p_iserror=1; return leftcounter; } if(leftcounter>0 && p_letters.indexOf(inputstring.charAt(leftcounter))>-1) while(p_letters.indexOf(inputstring.charAt(leftcounter))>-1 && leftcounter>=0) leftcounter--; } else { p_iserror=1; return leftcounter; } return leftcounter; }; function conCaret(inputstring)  { var transtring, inilen, mco, curpos, leftmove, rightmove, base, expon; inilen=inputstring.length; transtring=inputstring; if(transtring.indexOf("^")==-1)  return transtring; if(transtring.indexOf("^")==0)  { setError("Error at the first ^."); return ""; } if(transtring.charAt(transtring.length-1)=="^")  { setError("Error at the last ^."); return ""; } mco=0; while(transtring.indexOf("^")>0 && mco<inilen*6) { mco++; curpos=transtring.lastIndexOf("^"); leftmove=goLeft(transtring,curpos); if(p_iserror==1) { setError("Error at ^ number " + mco + " from the end."); return ""; } base=transtring.substring(leftmove+1,curpos); rightmove=goRight(transtring,curpos); if(p_iserror==1) { setError("Error at ^ number " + mco + " from the end."); return ""; } expon=transtring.substring(curpos+1, rightmove); transtring=transtring.substring(0,leftmove+1) + "pow("+ base+ "," + expon + ")" + transtring.substring(rightmove,transtring.length+1); } return transtring; }; function errorObject(messg, errStatus)  { var retObj=new CompiledObject(); with(retObj) { polishArray=[]; errorMes=messg; errorStatus=errStatus; } return retObj; }; function whiteSpaces(inputstring)  { var curpos, transtring, inilen, counter=0; inilen=inputstring.length; transtring=inputstring.toLowerCase(); while(transtring.indexOf(" ")>-1 && counter < inilen+1) { curpos=transtring.indexOf(" "); transtring=transtring.substring(0,curpos) + transtring.substring(curpos+1,transtring.length); counter+=1; } return transtring; }; function checkLegal(inputstring)  { var legal, curchar; for(var i=0; i<inputstring.length; i++) { curchar=inputstring.charAt(i); legal=p_digits.indexOf(curchar)+p_letters.indexOf(curchar)+p_operators.indexOf(curchar); if(legal==-3) { setError("Unknown characters in expression."); return false; } } return true; }; function checkPars(inputstring) { var i, j, matchpar, left=0, right=0, counter=0; for(i=0; i<inputstring.length; i++) { if(inputstring.charAt(i)=="(") left++; if(inputstring.charAt(i)==")") right++; } if(!(left==right)) { setError("Mismatched parentheses"); return false; } for(j=0; j<inputstring.length; j++) { if(inputstring.charAt(j)=="(") { matchpar=1; counter=0; while(matchpar>0 && counter<inputstring.length) { counter++; if(inputstring.charAt(j+counter)=="(") matchpar++; if(inputstring.charAt(j+counter)==")") matchpar--; } if(matchpar>0) { j++; setError("Mismatched parenthesis at position number " + j); return false; } } } for(j=0; j<inputstring.length; j++) { if(inputstring.charAt(j)==")") { matchpar=1; counter=0; while(matchpar>0 && counter<inputstring.length) { counter++; if(inputstring.charAt(j-counter)==")") matchpar++; if(inputstring.charAt(j-counter)=="(") matchpar--; } if(matchpar>0) { j++; setError("Mismatched parenthesis at position number " + j); return false; } } } return true; }; function makeStack(inputstring) { var mstring, minilen, mpos, mstack, checkStack, checkExpr, counter; mstring=inputstring; mpos=0; mstack=[]; checkStack=[]; minilen=mstring.length; checkExpr=[]; counter=0; while(mpos < minilen && counter<minilen*2) { if(nextToken(mstring,mpos)) { if(p_tokenType=="f1") { mstack.push(this[p_tokenvalue]); mstack.push("f1"); checkStack.push(this["sin"]); checkStack.push("f1"); } if(p_tokenType=="f2") { mstack.push(this[p_tokenvalue]); mstack.push("f2"); checkStack.push(this["plus"]); checkStack.push("f2"); } if(p_tokenType=="variable") { mstack.push(p_tokenvalue); mstack.push("variable"); checkStack.push("x"); checkStack.push("variable"); } if(p_tokenType=="num") { mstack.push(Number(p_tokenvalue)); mstack.push("num"); checkStack.push(Number(p_tokenvalue)); checkStack.push("num"); } } else { setError("Unknown characters."); return []; } mpos+=p_tokenLength; counter++; } mstack.reverse(); checkExpr=checkStack.reverse(); checkEval(checkExpr); if(p_iserror==1) return []; return(mstack); }; function setError(mess)  { p_errorMes="Syntax error: " + mess; p_iserror=1; }; function checkEval(compiledExpression) { var entrytype=""; var operands=[]; var arg1, arg2; for( var i=0; i<compiledExpression.length; i++) { entrytype=compiledExpression[i++]; if(entrytype=="num") { operands.push(compiledExpression[i]); } else if( entrytype=="variable") { operands.push(1); } else if( entrytype=="f1") { if(operands.length<1) { setError("Check number of arguments in functions."); return;} operands.push(compiledExpression[i](operands.pop())) } else if( entrytype=="f2") { if(operands.length<2){ setError("Check number of arguments in functions."); return;} arg1=operands.pop(); arg2=operands.pop(); operands.push(compiledExpression[i](arg1,arg2)); } else { setError("Can't evaluate."); return; } } if(!(operands.length==1)) { setError(""); return; } if(isNaN(operands[0])) { setError(""); return; } }; function sin(a) {return Math.sin(a);}; function cos(a) {return Math.cos(a);}; function tan(a) {return Math.tan(a);}; function ln(a) {return Math.log(a);}; function log(a) {return Math.log(a)/Math.log(10);}; function sqrt(a) {return Math.sqrt(a);}; function exp(a) {return Math.exp(a);}; function abs(a) {return Math.abs(a);}; function asin(a) {return Math.asin(a);}; function acos(a) {return Math.acos(a);}; function atan(a) {return Math.atan(a);}; function sec(a) {return 1/Math.cos(a);}; function csc(a) {return 1/Math.sin(a);}; function cot(a) {return 1/Math.tan(a);}; function floor(a) {return Math.floor(a);}; function ceil(a) {return Math.ceil(a);}; function round(a) {return Math.round(a);}; function max(a,b) {return Math.max(a,b);}; function min(a,b) {return Math.min(a,b);}; function plus(a,b) {return a + b;}; function minus(a,b) {return a - b;}; function mul(a,b) {return a * b;}; function div(a,b) {return a / b; }; function pow(a, b) { if (a<0 && b==Math.floor(b)) { if((b % 2)==0) return Math.pow(-a, b); else return -Math.pow (-a, b); } if (a==0 && b>0) return 0; if(isNaN(a) && b==0) return NaN; return Math.pow (a, b); }; function doEval(compiledObject, aVarVals) { var entrytype=""; var operands=[]; var compiledExp=compiledObject.polishArray; var numItems=compiledExp.length; var arg0; var arg1; var arg2; var item; for(var i=0; i < numItems; i++) { entrytype=compiledExp[i++]; item=compiledExp[i]; if(entrytype=="num") { operands.push(item); } else if( entrytype=="variable") { if(item=="e") { operands.push(Math.E); } else if(item=="pi") { operands.push(Math.PI); } else { for(var k=0; k < p_varNames.length; k++)  { if(item==p_varNames[k]) { operands.push(aVarVals[k]); break; } } } } else if( entrytype=="f1")  { arg0=operands.pop(); if(item==sin) { operands.push(Math.sin(arg0)); } else if(item==cos) { operands.push(Math.cos(arg0)); } else if(item==tan) { operands.push(Math.tan(arg0)); } else if(item==asin) { operands.push(Math.asin(arg0)); } else if(item==acos) { operands.push(Math.acos(arg0)); } else if(item==atan) { operands.push(Math.atan(arg0)); } else if(item==ln ) { operands.push(Math.log(arg0)); } else if(item==sqrt) { operands.push(Math.sqrt(arg0)); } else if(item==exp) { operands.push(Math.exp(arg0)); } else if(item==abs) { operands.push(Math.abs(arg0)); } else if(item==ceil) { operands.push(Math.ceil(arg0)); } else if(item==floor){ operands.push(Math.floor(arg0));} else if(item==round){ operands.push(Math.round(arg0));} else { operands.push(item(arg0)); } } else if(entrytype=="f2")  { arg1=operands.pop(); arg2=operands.pop(); if(item==mul) { operands.push(arg1*arg2); } else if(item==plus) { operands.push(arg1+arg2); } else if(item==minus){ operands.push(arg1-arg2); } else if(item==div) { operands.push(arg1/arg2); } else if(item==pow) { operands.push(Math.pow(arg1,arg2));} else if(item==min) { operands.push(Math.min(arg1,arg2));} else if(item==max) { operands.push(Math.max(arg1,arg2));} else { operands.push(item(arg1,arg2)); } } else { return NaN; } } return operands[0] }; function CompiledObject()    { this.polishArray=[];  this.errorMes=""; this.errorStatus=0; }; function Plotter(wid, ht)  { this.type="Plotter"; this.wid=wid; this.ht=ht; this.wid;  this.ht;  this.xMin;  this.xMax;  this.yMin;  this.yMax;  this.lineWid=1; this.lineCol=0x000000; this.lineAlph=1; this.shadeColor=0x00ff00;  this.shadeAlpha=0.2; this.visibleLine=true; this.dashed=false; this.topShade=false; this.bottomShade=false; this.prevX; this.prevY; this.dashCtr; this.dashLen=7; this.spaceLen=1; this.inDash=true; this.can;  this.context;   this.can=document.createElement('canvas'); with( this.can) { with(style) { position="absolute"; top= (graphTop*bScale)+"px"; left=(graphLeft*bScale)+"px"; } width=graphWidth*bScale; height=graphHeight*bScale; }  document.body.appendChild(this.can); this.context=this.can.getContext('2d'); this.context.scale(bScale, bScale);   this.dashCan=document.createElement('canvas'); with( this.dashCan) { with(style) { position="absolute"; top= (graphTop*bScale)+"px"; left=(graphLeft*bScale)+"px"; } width=graphWidth*bScale; height=graphHeight*bScale; }  document.body.appendChild(this.dashCan); this.dashCtx=this.dashCan.getContext('2d'); this.dashCtx.scale(bScale, bScale); this.clear=function() { this.context.clearRect(0, 0, graphWidth, graphHeight); this.dashCtx.clearRect(0, 0, graphWidth, graphHeight); this.dashed=false; this.topShade=false; this.bottomShade=false; }; this.init=function(xMin, xMax, yMin, yMax) { this.xMin=xMin; this.xMax=xMax; this.yMin=yMin; this.yMax=yMax; this.clear(); }; this.setVisible=function(val) { this.visibleLine=val; }; this.setDashed=function(val) { this.dashed=val; }; this.setTopShading=function() { this.topShade=true; this.bottomShade=false; }; this.setBottomShading=function() { this.topShade=false; this.bottomShade=true; }; this.beginPlot=function(lineWid, lineCol, lineAlph, shadeColor) { this.lineWid=lineWid; this.lineCol=lineCol; this.lineAlph=lineAlph; this.prevX=this.prevY=0; if (this.topShade || this.bottomShade) { this.context.fillStyle=toStr(shadeColor, this.shadeAlpha); } this.context.beginPath(); this.context.lineWidth=this.lineWid; this.dashCtx.beginPath(); this.dashCtx.lineWidth=this.lineWid; this.dashCtx.strokeStyle=toStr(this.lineCol, this.lineAlpha); this.dashLen=4; this.spaceLen=2; this.dashCtr=this.dashLen; this.inDash=true; }; this.plotPoint=function(xPix ,mathy) {  var yPix=this.ht*(this.yMax - mathy)/(this.yMax- this.yMin) ; if(this.visibleLine)  this.context.strokeStyle=toStr(this.lineCol, this.lineAlph); else this.context.strokeStyle=toStr(this.lineCol, 0);  this.context.lineTo(xPix,yPix); this.prevX=xPix; this.prevY=yPix;   if(this.dashed) { this.dashCtr--; if(this.inDash) { this.dashCtx.lineTo(xPix,yPix); if(this.dashCtr <=0)  { this.dashCtr=this.spaceLen; this.inDash=false; this.dashCtx.stroke(); } } else { if(this.dashCtr <=0)  { this.dashCtx.beginPath(); this.dashCtr=this.dashLen; this.inDash=true; } } } };  this.endPlot=function() { if(this.dashed) this.dashCtx.stroke(); else this.context.stroke();    if(this.topShade)  with(this.context) { this.context.strokeStyle=toStr(this.lineCol, 0);  lineTo(wid, 0); lineTo(0,0); fill(); } if(this.bottomShade)  with(this.context) { this.context.strokeStyle=toStr(this.lineCol, 0);  lineTo(this.wid, this.ht); lineTo(0 ,this.ht); fill(); } this.topShade=this.bottomShade=false; this.visibleLine=true; }; } ;